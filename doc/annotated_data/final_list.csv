PaperID,Title,Author,Year,DOI,Venue,Link,Publisher,Abstract,BibTeX,Basic-Testing4Quantum?,Basic-QSTAndEmpirical?,Basic-UnifiedVenue,Basic-VenueType,Basic-PaperScope,Programs-ProgramName,Toolings-AvailableProgramSource,Programs-#OfObjects,BuggyVersion-FaultGeneration,BuggyVersion-#OfVersions,Scalability-InvolveScalability?,Scalability-#OfQubits,Scalability-#OfGates,Scalability-CircuitDepth,AdoptedBaseline-InvolveBaseline?,AdoptedBaseline-BaselineNames,AdoptedBaseline-InclusionMethod,BaselineComparison-Method,TestCases-InputType,TestCases-#OfTestCases,Backends-SimulatorOrHardware,Backends-OutputType?,StatisticalRepeats-Shots,StatisticalRepeats-IndependentRepeats,TestOracle-OutputExpectation,TestOracle-OracleName,Metrics-Effectiveness,Metrics-Cost,Toolings-BenchmarkAvailable&Complete?,Toolings-ArtifactAvailableLink
1.0,Muskit: a mutation analysis tool for quantum software testing,"Mendiluze, E\~{n}aut and Ali, Shaukat and Arcaini, Paolo and Yue, Tao",2022.0,10.1109/ASE51524.2021.9678563,Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering,https://doi.org/10.1109/ASE51524.2021.9678563,IEEE Press,"Given that quantum software testing is a new area of research, there is a lack of benchmark programs and bugs repositories to assess the effectiveness of testing techniques. To this end, quantum mutation analysis focuses on systematically generating faulty versions of Quantum Programs (QPs), called mutants, using mutation operators. Such mutants can be used as benchmarks to assess the quality of test cases in a test suite. Thus, we present Muskit - a quantum mutation analysis tool for QPs coded in IBM's Qiskit language. Muskit defines mutation operators on gates of QPs and selection criteria to reduce the number of mutants to generate. Moreover, it allows for the execution of test cases on mutants and generation of results for test analyses. Muskit is provided as command line interface, GUI, and web application. We validated Muskit by using it to generate and execute mutants for four QPs. Muskit code: https://github.com/Simula-COMPLEX/muskitWeb app: https://qiskitmutantcreatorsrl.pythonanywhere.com/YouTube Video: EbPHJOK_AEA Artifact Available: https://doi.org/10.5281/zenodo.5288917","@inproceedings{10.1109/ASE51524.2021.9678563,
  year = {2022},
  url = {https://doi.org/10.1109/ASE51524.2021.9678563},
  title = {Muskit: a mutation analysis tool for quantum software testing},
  series = {ASE '21},
  publisher = {IEEE Press},
  pages = {1266–1270},
  numpages = {5},
  month = {Nov},
  location = {Melbourne, Australia},
  keywords = {Software testing,Codes,Computer bugs,Logic gates,Benchmark testing,Circuit faults,Software engineering,quantum programs,software testing,mutation analysis,quantum circuits},
  issn = {2643-1572},
  isbn = {9781665403375},
  doi = {10.1109/ASE51524.2021.9678563},
  booktitle = {Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering},
  author = {Mendiluze, E\~{n}aut and Ali, Shaukat and Arcaini, Paolo and Yue, Tao},
  abstract = {Given that quantum software testing is a new area of research, there is a lack of benchmark programs and bugs repositories to assess the effectiveness of testing techniques. To this end, quantum mutation analysis focuses on systematically generating faulty versions of Quantum Programs (QPs), called mutants, using mutation operators. Such mutants can be used as benchmarks to assess the quality of test cases in a test suite. Thus, we present Muskit - a quantum mutation analysis tool for QPs coded in IBM's Qiskit language. Muskit defines mutation operators on gates of QPs and selection criteria to reduce the number of mutants to generate. Moreover, it allows for the execution of test cases on mutants and generation of results for test analyses. Muskit is provided as command line interface, GUI, and web application. We validated Muskit by using it to generate and execute mutants for four QPs. Muskit code: https://github.com/Simula-COMPLEX/muskitWeb app: https://qiskitmutantcreatorsrl.pythonanywhere.com/YouTube Video: EbPHJOK_AEA Artifact Available: https://doi.org/10.5281/zenodo.5288917},
}",[Y],[Y],[International Conference on Automated Software Engineering (ASE)],[Conference],[Software testing],"[Quantum algorithms and subroutines: Quantum Fourier Transform <Inverse Quantum Fourier Transform>, Quantum Random Access Memory,Bernstein-Vazirani Algorithm, Quantum Conditional Execution]",[Un-specified],[Quantum algorithms and subroutines:4],"[Mutation operators: Add gate, Remove gate, Replace gate]",[Mutants: 1544],[N],"[6, 7]","[Total: 9, 12]",[Un-specified],[N],N/A,N/A,N/A,[Initial quantum states: Computational basis states],"[64, 128]",[Un-specified],[Measurement outcome],[Fixed: 100],[Un-specified],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle: specified]",[Mutation score],[Overall execution time],[Y],"[GitHub: https://github.com/Simula-COMPLEX/muskit],[Zenodo: https://zenodo.org/records/5288917]"
3.0,Quito: a coverage-guided test generator for quantum programs,"Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat",2022.0,10.1109/ASE51524.2021.9678798,Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering,https://doi.org/10.1109/ASE51524.2021.9678798,IEEE Press,"Automation in quantum software testing is essential to support systematic and cost-effective testing. Towards this direction, we present a quantum software testing tool called Quito that can automatically generate test suites covering three coverage criteria defined on inputs and outputs of a quantum program coded in Qiskit, i.e., input coverage, output coverage, and input-output coverage. Quito also implements two types of test oracles based on program specifications, i.e., checking whether a quantum program produced a wrong output or checking a probabilistic test oracle with statistical test. We describe the architecture and methodology of the tool. We also validated the tool with one quantum program and one faulty version of it. Results indicate that Quito can generate test suites and perform test assessments that detect faults, and produce test results with a good time performance.Quito's code: https://github.com/Simula-COMPLEX/quitoQuito's video: https://youtu.be/kuI9QaCo8A8Artifact Available: https://doi.org/10.5281/zenodo.5288665","@inproceedings{10.1109/ASE51524.2021.9678798,
  year = {2022},
  url = {https://doi.org/10.1109/ASE51524.2021.9678798},
  title = {Quito: a coverage-guided test generator for quantum programs},
  series = {ASE '21},
  publisher = {IEEE Press},
  pages = {1237–1241},
  numpages = {5},
  month = {Nov},
  location = {Melbourne, Australia},
  keywords = {Software testing,Computer languages,Systematics,Codes,Computer architecture,Probabilistic logic,Software,quantum programs,software testing,coverage criteria,test generation,test assessment},
  issn = {2643-1572},
  isbn = {9781665403375},
  doi = {10.1109/ASE51524.2021.9678798},
  booktitle = {Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering},
  author = {Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat},
  abstract = {Automation in quantum software testing is essential to support systematic and cost-effective testing. Towards this direction, we present a quantum software testing tool called Quito that can automatically generate test suites covering three coverage criteria defined on inputs and outputs of a quantum program coded in Qiskit, i.e., input coverage, output coverage, and input-output coverage. Quito also implements two types of test oracles based on program specifications, i.e., checking whether a quantum program produced a wrong output or checking a probabilistic test oracle with statistical test. We describe the architecture and methodology of the tool. We also validated the tool with one quantum program and one faulty version of it. Results indicate that Quito can generate test suites and perform test assessments that detect faults, and produce test results with a good time performance.Quito's code: https://github.com/Simula-COMPLEX/quitoQuito's video: https://youtu.be/kuI9QaCo8A8Artifact Available: https://doi.org/10.5281/zenodo.5288665},
}",[Y],[Y],[International Conference on Automated Software Engineering (ASE)],[Conference],[Software testing],[Quantum algorithms and subroutines: Quantum Random Access Memory],[Un-specified],[Quantum algorithms and subroutines:1],[Mutation operators: Add gate],[Versions: 1],[N],[7],"[Total: 9, 10]",[Un-specified],[N],N/A,N/A,N/A,[Initial quantum states: Computational basis states],"[48000, 15324, 203366]",[Ideal simulator],[Measurement outcome],[Un-specified],[Un-specified],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle: Wilcoxon signed rank test]",[Percentage of failling tests],[Simulation time],[Y],"[GitHub: https://github.com/Simula-COMPLEX/quito], [Zenodo: https://zenodo.org/records/5288665]"
5.0,QuCAT: A Combinatorial Testing Tool for Quantum Software,"Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat",2024.0,10.1109/ASE56229.2023.00062,Proceedings of the 38th IEEE/ACM International Conference on Automated Software Engineering,https://doi.org/10.1109/ASE56229.2023.00062,IEEE Press,"With the increased developments in quantum computing, the availability of systematic and automatic testing approaches for quantum programs is becoming increasingly essential. To this end, we present the quantum software testing tool QuCAT for combinatorial testing of quantum programs. QuCAT provides two functionalities of use. With the first functionality, the tool generates a test suite of a given strength (e.g., pair-wise). With the second functionality, it generates test suites with increasing strength until a failure is triggered or a maximum strength is reached. QuCAT uses two test oracles to check the correctness of test outputs. We assess the cost and effectiveness of QuCAT with 3 faulty versions of 5 quantum programs. Results show that combinatorial test suites with a low strength can find faults with limited cost, while a higher strength performs better to trigger some difficult faults with relatively higher cost. Repository: https://github.com/Simula- COMPLEX/qucat- tool Video: https://youtu.be/UsqgOudKLio","@inproceedings{10.1109/ASE56229.2023.00062,
  year = {2024},
  url = {https://doi.org/10.1109/ASE56229.2023.00062},
  title = {QuCAT: A Combinatorial Testing Tool for Quantum Software},
  series = {ASE '23},
  publisher = {IEEE Press},
  pages = {2066–2069},
  numpages = {4},
  month = {Sep.},
  location = {Echternach, Luxembourg},
  keywords = {Costs,Quantum computing,Systematics,Combinatorial testing,Automatic testing,Software,Software engineering,quantum programs,software testing,combinatorial testing},
  issn = {2643-1572},
  isbn = {9798350329964},
  doi = {10.1109/ASE56229.2023.00062},
  booktitle = {Proceedings of the 38th IEEE/ACM International Conference on Automated Software Engineering},
  author = {Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat},
  abstract = {With the increased developments in quantum computing, the availability of systematic and automatic testing approaches for quantum programs is becoming increasingly essential. To this end, we present the quantum software testing tool QuCAT for combinatorial testing of quantum programs. QuCAT provides two functionalities of use. With the first functionality, the tool generates a test suite of a given strength (e.g., pair-wise). With the second functionality, it generates test suites with increasing strength until a failure is triggered or a maximum strength is reached. QuCAT uses two test oracles to check the correctness of test outputs. We assess the cost and effectiveness of QuCAT with 3 faulty versions of 5 quantum programs. Results show that combinatorial test suites with a low strength can find faults with limited cost, while a higher strength performs better to trigger some difficult faults with relatively higher cost. Repository: https://github.com/Simula- COMPLEX/qucat- tool Video: https://youtu.be/UsqgOudKLio},
}",[Y],[Y],[International Conference on Automated Software Engineering (ASE)],[Conference],[Software testing],"[Quantum algorithms and subroutines:Bernstein-Vazirani Algorithm, Quantum Random Access Memory, Quantum Fourier Transform <Inverse Quantum Fourier Transform>, Quantum Conditional Execution, Add Squared Algorithm, Simon's Algorithm]",[Un-specified],[Quantum algorithms and subroutines:6],[Mutation operators: Add gate],[Versions: 15],[N],"[6, 7, 11, 10, 9]","[Total: 21, 15, 60, 25]","[3, 12, 56, 22, 26]",[N],[Random testing],[Naivety],"[Mann-Whitney U test: $p$-value, Vargha and Delaney's $\hat{A}_{12}$ statistics], [Fisher's exact test: Odds ratio]",[Initial quantum states: Computational basis states],[500],[Ideal simulator],[Measurement outcome],[Adaptive: the number of possible outputs for a specific input multiplied by 100],[500],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle: Pearson's chi-square test]","[success rate: the number of times a test suite found a fault out of the total number of runs, fault detection: average success rate over all faulty programs]",[Number of needed tests to find a fault],[Y],[GitHub: https://github.com/Simula-COMPLEX/qucat-tool]
6.0,QuraTest: Integrating Quantum Specific Features in Quantum Program Testing,"Ye, Jiaming and Xia, Shangzhou and Zhang, Fuyuan and Arcaini, Paolo and Ma, Lei and Zhao, Jianjun and Ishikawa, Fuyuki",2024.0,10.1109/ASE56229.2023.00196,Proceedings of the 38th IEEE/ACM International Conference on Automated Software Engineering,https://doi.org/10.1109/ASE56229.2023.00196,IEEE Press,"The recent fast development of quantum computers breaks several computation limitations that are difficult for conventional computers. Up to the present, although many approaches and tools have been proposed to test quantum programs, the fundamental features of quantum programs, i.e., magnitude, phase, and entanglement, have been largely overlooked, leading to limited fault detection capability and reduced testing effectiveness. To address this problem, we propose an automated testing framework named QURATEST, equipped with three test case generators (including two newly proposed techniques, UCNOT and IQFT in this paper, as well as one based on Random techniques) to test quantum programs. Overall, the proposed generators enable the generation of diverse test inputs by considering the quantum features of quantum programs. In the experiments, we perform an in-depth evaluation of QURATEST from three aspects: generated test case diversity, output coverage of the program under test, and fault detection capability. The results demonstrate the potential of our newly proposed techniques in that IQFT can generate the most diverse test cases regarding magnitude, phase, and entanglement, with 66% cell coverage. Comparatively, the Random approach only has 10% cell coverage. Regarding the evaluations of the output coverage, IQFT can achieve the highest output coverage in 70.2% (33 out of 47) of all quantum programs. In terms of fault detection, UCNOT outperforms the other two techniques. Specifically, the test cases generated by UCNOT have the best mutation score in 88.4% (23 out of 26) quantum programs.","@inproceedings{10.1109/ASE56229.2023.00196,
  year = {2024},
  url = {https://doi.org/10.1109/ASE56229.2023.00196},
  title = {QuraTest: Integrating Quantum Specific Features in Quantum Program Testing},
  series = {ASE '23},
  publisher = {IEEE Press},
  pages = {1149–1161},
  numpages = {13},
  month = {Sep.},
  location = {Echternach, Luxembourg},
  keywords = {Computers,Software testing,Quantum computing,Quantum entanglement,Fault detection,Reliability engineering,Generators,Quantum program,test case generation,magnitude,phase,entanglement},
  issn = {2643-1572},
  isbn = {9798350329964},
  doi = {10.1109/ASE56229.2023.00196},
  booktitle = {Proceedings of the 38th IEEE/ACM International Conference on Automated Software Engineering},
  author = {Ye, Jiaming and Xia, Shangzhou and Zhang, Fuyuan and Arcaini, Paolo and Ma, Lei and Zhao, Jianjun and Ishikawa, Fuyuki},
  abstract = {The recent fast development of quantum computers breaks several computation limitations that are difficult for conventional computers. Up to the present, although many approaches and tools have been proposed to test quantum programs, the fundamental features of quantum programs, i.e., magnitude, phase, and entanglement, have been largely overlooked, leading to limited fault detection capability and reduced testing effectiveness. To address this problem, we propose an automated testing framework named QURATEST, equipped with three test case generators (including two newly proposed techniques, UCNOT and IQFT in this paper, as well as one based on Random techniques) to test quantum programs. Overall, the proposed generators enable the generation of diverse test inputs by considering the quantum features of quantum programs. In the experiments, we perform an in-depth evaluation of QURATEST from three aspects: generated test case diversity, output coverage of the program under test, and fault detection capability. The results demonstrate the potential of our newly proposed techniques in that IQFT can generate the most diverse test cases regarding magnitude, phase, and entanglement, with 66% cell coverage. Comparatively, the Random approach only has 10% cell coverage. Regarding the evaluations of the output coverage, IQFT can achieve the highest output coverage in 70.2% (33 out of 47) of all quantum programs. In terms of fault detection, UCNOT outperforms the other two techniques. Specifically, the test cases generated by UCNOT have the best mutation score in 88.4% (23 out of 26) quantum programs.},
}",[Y],[Y],[International Conference on Automated Software Engineering (ASE)],[Conference],[Software testing],"[Quantum algorithms and subroutines: Quantum Adder,Bernstein-Vazirani Algorithm, Random Clifford, Quantum Fourier Transform, Quantum Phase Estimation <PE and DPC PE>]","[VeriQBench: [@article{chen2022VeriQBench,
  title={VeriQBench: A benchmark for multiple types of quantum circuits},
  author={Chen, Kean and Fang, Wang and Guan, Ji and Hong, Xin and Huang, Mingyu and Liu, Junyi and Wang, Qisheng and Ying, Mingsheng},
  journal={arXiv preprint arXiv:2206.10880},
  year={2022}
}], Un-specified]",[Quantum algorithms and subroutines:8],[Mutation toolings: QmutPy],[Mutants: 18505],[Y],"[3, 4, 5, 6, 7, 8, 10]",[Un-specified],[Un-specified],[Y],[Random circuit generator <Random generators>],[Naivety],[Un-specified],"[Initial quantum states: States with the magnitude, phase, and entanglement]",[100],[Ideal simulator],[Measurement outcome],"[Adaptive: $10^4$ for programs with 4 or 5 qubits, and $10^5$ for programs with 6 or 7 qubits]",[10],[Original program output],[Un-specified],"[Magnitude score], [Phase score], [Entanglement score], [Output coverage]",[Un-specified],[N],N/A
12.0,Statistical assertions for validating patterns and finding bugs in quantum programs,"Huang, Yipeng and Martonosi, Margaret",2019.0,10.1145/3307650.3322213,Proceedings of the 46th International Symposium on Computer Architecture,https://doi.org/10.1145/3307650.3322213,Association for Computing Machinery,"In support of the growing interest in quantum computing experimentation, programmers need new tools to write Quantum algorithms and subroutines as program code. Compared to debugging classical programs, debugging quantum programs is difficult because programmers have limited ability to probe the internal states of quantum programs, those states are difficult to interpret even when observations exist, and programmers do not yet have guidelines for what to check for when building quantum programs. In this work, we present quantum program assertions based on statistical tests on classical observations. These allow programmers to decide if a quantum program state matches its expected value in one of classical, superposition, or entangled types of states. We extend an existing quantum programming language with the ability to specify quantum assertions, which our tool then checks in a quantum program simulator. We use these assertions to debug three benchmark quantum programs in factoring, search, and chemistry. We share what types of bugs are possible, and lay out a strategy for using quantum programming patterns to place assertions and prevent bugs.","@inproceedings{10.1145/3307650.3322213,
  year = {2019},
  url = {https://doi.org/10.1145/3307650.3322213},
  title = {Statistical assertions for validating patterns and finding bugs in quantum programs},
  series = {ISCA '19},
  publisher = {Association for Computing Machinery},
  pages = {541–553},
  numpages = {13},
  location = {Phoenix, Arizona},
  keywords = {assertions, chi-square test, correctness, debugging, program patterns, quantum computing, validation},
  isbn = {9781450366694},
  doi = {10.1145/3307650.3322213},
  booktitle = {Proceedings of the 46th International Symposium on Computer Architecture},
  author = {Huang, Yipeng and Martonosi, Margaret},
  address = {New York, NY, USA},
  abstract = {In support of the growing interest in quantum computing experimentation, programmers need new tools to write Quantum algorithms and subroutines as program code. Compared to debugging classical programs, debugging quantum programs is difficult because programmers have limited ability to probe the internal states of quantum programs, those states are difficult to interpret even when observations exist, and programmers do not yet have guidelines for what to check for when building quantum programs. In this work, we present quantum program assertions based on statistical tests on classical observations. These allow programmers to decide if a quantum program state matches its expected value in one of classical, superposition, or entangled types of states. We extend an existing quantum programming language with the ability to specify quantum assertions, which our tool then checks in a quantum program simulator. We use these assertions to debug three benchmark quantum programs in factoring, search, and chemistry. We share what types of bugs are possible, and lay out a strategy for using quantum programming patterns to place assertions and prevent bugs.},
}",[Y],[Y],[International Symposium on Computer Architecture (ISCA)],[Conference],[Runtime assertion],"[Quantum algorithms and subroutines: Shor's Algorithm,Grover Search, Hydrogen Molecule Ground State Energy Simulation],[Quantum applications: Quantum Chemistry]",[Un-specified],[Quantum algorithms and subroutines:3],[Un-specified],[Un-specified],[N],[Un-specified],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,"[Classical inputs: Coefficient for rotations], [Initial quantum states: Computational basis states]",[Un-specified],[Ideal simulator],[Measurement outcome],[Un-specified],[Un-specified],[Specification: Probability distribution],[Property-based oracle: Pearson's chi-square test],[Un-specified],[Un-specified],[N],N/A
13.0,Property-based Testing of Quantum Programs in Q#,"Honarvar, Shahin and Mousavi, Mohammad Reza and Nagarajan, Rajagopal",2020.0,10.1145/3387940.3391459,Proceedings of the IEEE/ACM 42nd International Conference on Software Engineering Workshops,https://doi.org/10.1145/3387940.3391459,Association for Computing Machinery,"Property-based testing is a structured method for automated testing using program specifications. We report on the design and implementation of what is to our knowledge the first property-based framework for quantum programs. We review various aspects of our design concerning property-specification, test-case generation, and test result analysis. We also provide an overview of the implementation and its way of working. Finally, we present the result of applying our framework to some examples.","@inproceedings{10.1145/3387940.3391459,
  year = {2020},
  url = {https://doi.org/10.1145/3387940.3391459},
  title = {Property-based Testing of Quantum Programs in Q#},
  series = {ICSEW'20},
  publisher = {Association for Computing Machinery},
  pages = {430–435},
  numpages = {6},
  location = {Seoul, Republic of Korea},
  keywords = {property-based testing, quantumcomputation, quantumprograms, software testing},
  isbn = {9781450379632},
  doi = {10.1145/3387940.3391459},
  booktitle = {Proceedings of the IEEE/ACM 42nd International Conference on Software Engineering Workshops},
  author = {Honarvar, Shahin and Mousavi, Mohammad Reza and Nagarajan, Rajagopal},
  address = {New York, NY, USA},
  abstract = {Property-based testing is a structured method for automated testing using program specifications. We report on the design and implementation of what is to our knowledge the first property-based framework for quantum programs. We review various aspects of our design concerning property-specification, test-case generation, and test result analysis. We also provide an overview of the implementation and its way of working. Finally, we present the result of applying our framework to some examples.},
}",[Y],[Y],[International Conference on Software Engineering Workshops (ICSEW)],[Workshop],[Software testing],"[Quantum algorithms and subroutines: Quantum Teleportation, Superdense Coding]",[Un-specified],[Quantum algorithms and subroutines:2],"[Mutation operators: Add gate, Modify qubit, Switch qubit, Modify conditional, Switch gate, Duplicate gate, Add conditional, Delete conditional]",[Mutants: 40],[N],[Un-specified],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Initial quantum states: Separable states modelled by Bloch sphere],[10],[Ideal simulator],[Measurement outcome],[Fixed: 350],[Un-specified],[Original program output],"[Property-based oracle: T test, Pearson's chi-square test]",[Mutation score],[Overall execution time],[Y],[GitHub: https://github.com/ShahinHonarvar/QSharpCheck]
14.0,Projection-based runtime assertions for testing and debugging Quantum programs,"Li, Gushu and Zhou, Li and Yu, Nengkun and Ding, Yufei and Ying, Mingsheng and Xie, Yuan",2020.0,10.1145/3428218,Proc. ACM Program. Lang.,https://doi.org/10.1145/3428218,Association for Computing Machinery,"In this paper, we propose Proq, a runtime assertion scheme for testing and debugging quantum programs on a quantum computer. The predicates in Proq are represented by projections (or equivalently, closed subspaces of the state space), following Birkhoff-von Neumann quantum logic. The satisfaction of a projection by a quantum state can be directly checked upon a small number of projective measurements rather than a large number of repeated executions. On the theory side, we rigorously prove that checking projection-based assertions can help locate bugs or statistically assure that the semantic function of the tested program is close to what we expect, for both exact and approximate quantum programs. On the practice side, we consider hardware constraints and introduce several techniques to transform the assertions, making them directly executable on the measurement-restricted quantum computers. We also propose to achieve simplified assertion implementation using local projection technique with soundness guaranteed. We compare Proq with existing quantum program assertions and demonstrate the effectiveness and efficiency of Proq by its applications to assert two sophisticated Quantum algorithms and subroutines, the Harrow-Hassidim-Lloyd algorithm and Shor’s algorithm.","@article{10.1145/3428218,
  year = {2020},
  volume = {4},
  url = {https://doi.org/10.1145/3428218},
  title = {Projection-based runtime assertions for testing and debugging Quantum programs},
  publisher = {Association for Computing Machinery},
  numpages = {29},
  number = {OOPSLA},
  month = {November},
  keywords = {assertion, program testing, quantum computing, quantum programming},
  journal = {Proc. ACM Program. Lang.},
  issue_date = {November 2020},
  doi = {10.1145/3428218},
  author = {Li, Gushu and Zhou, Li and Yu, Nengkun and Ding, Yufei and Ying, Mingsheng and Xie, Yuan},
  articleno = {150},
  address = {New York, NY, USA},
  abstract = {In this paper, we propose Proq, a runtime assertion scheme for testing and debugging quantum programs on a quantum computer. The predicates in Proq are represented by projections (or equivalently, closed subspaces of the state space), following Birkhoff-von Neumann quantum logic. The satisfaction of a projection by a quantum state can be directly checked upon a small number of projective measurements rather than a large number of repeated executions. On the theory side, we rigorously prove that checking projection-based assertions can help locate bugs or statistically assure that the semantic function of the tested program is close to what we expect, for both exact and approximate quantum programs. On the practice side, we consider hardware constraints and introduce several techniques to transform the assertions, making them directly executable on the measurement-restricted quantum computers. We also propose to achieve simplified assertion implementation using local projection technique with soundness guaranteed. We compare Proq with existing quantum program assertions and demonstrate the effectiveness and efficiency of Proq by its applications to assert two sophisticated Quantum algorithms and subroutines, the Harrow-Hassidim-Lloyd algorithm and Shor’s algorithm.},
}",[Y],[Y],"[International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)]",[Conference],[Runtime assertion],"[Quantum algorithms and subroutines: Shor's Algorithm, Harrow-Hassidim-Lloyd Algorithm]",[Un-specified],[Quantum algorithms and subroutines:2],[None],[None],[N],[5],[Un-specified],[Un-specified],[Y],"[Stat], [QECA]","[SOTA],[SOTA]",[Un-specified],[Classical inputs: Orthonormal vectors],[1],[Ideal simulator],[State vector],N/A,[Un-specified],[Specification: Quantum state],[Un-specified],[Un-specified],[Circuit cost],[N],N/A
15.0,Test Points for Online Monitoring of Quantum Circuits,"Acharya, Nikita and Urbanek, Miroslav and De Jong, Wibe A. and Saeed, Samah Mohamed",2021.0,10.1145/3477928,J. Emerg. Technol. Comput. Syst.,https://doi.org/10.1145/3477928,Association for Computing Machinery,"Noisy Intermediate-Scale Quantum (NISQ) computers consisting of tens of inherently noisy quantum bits (qubits) suffer from reliability problems. Qubits and their gates are susceptible to various types of errors. Due to limited numbers of qubits and high error rates, quantum error correction cannot be applied. Physical constraints of quantum hardware including the error rates are used to guide the design and the layout of quantum circuits. The error rates determine the selection of qubits and their operations. The resulting circuit is executed on the quantum computer.This study explores the risk of unexpected changes in the error rates of NISQ computers post-calibration. We show that unexpected changes in error rates can alter the output state of a quantum circuit. To detect these changes, we propose the insertion of test points into the quantum circuit to enable online monitoring of the physical qubit behavior. We utilize classical, superposition, and uncompute test points. Furthermore, we use a gate error coverage metric to assess the quality of the tests. We verify the effectiveness of the proposed scheme on different IBM quantum computers (IBM Q), in addition to a noisy simulation that shows the scalability of the proposed approach.","@article{10.1145/3477928,
  year = {2021},
  volume = {18},
  url = {https://doi.org/10.1145/3477928},
  title = {Test Points for Online Monitoring of Quantum Circuits},
  publisher = {Association for Computing Machinery},
  numpages = {19},
  number = {1},
  month = {October},
  keywords = {Quantum circuit, quantum circuit test point, Noisy Intermediate-Scale Quantum (NISQ) computer, side-channel information, mapping, reliability, security},
  journal = {J. Emerg. Technol. Comput. Syst.},
  issue_date = {January 2022},
  issn = {1550-4832},
  doi = {10.1145/3477928},
  author = {Acharya, Nikita and Urbanek, Miroslav and De Jong, Wibe A. and Saeed, Samah Mohamed},
  articleno = {14},
  address = {New York, NY, USA},
  abstract = {Noisy Intermediate-Scale Quantum (NISQ) computers consisting of tens of inherently noisy quantum bits (qubits) suffer from reliability problems. Qubits and their gates are susceptible to various types of errors. Due to limited numbers of qubits and high error rates, quantum error correction cannot be applied. Physical constraints of quantum hardware including the error rates are used to guide the design and the layout of quantum circuits. The error rates determine the selection of qubits and their operations. The resulting circuit is executed on the quantum computer.This study explores the risk of unexpected changes in the error rates of NISQ computers post-calibration. We show that unexpected changes in error rates can alter the output state of a quantum circuit. To detect these changes, we propose the insertion of test points into the quantum circuit to enable online monitoring of the physical qubit behavior. We utilize classical, superposition, and uncompute test points. Furthermore, we use a gate error coverage metric to assess the quality of the tests. We verify the effectiveness of the proposed scheme on different IBM quantum computers (IBM Q), in addition to a noisy simulation that shows the scalability of the proposed approach.},
}",[Y],[Y],[ACM Journal on Emerging Technologies in Computing Systems (JETC)],[Journal],[Software testing],"[Quantum algorithms and subroutines: Grover Search,Bernstein-Vazirani Algorithm, Quantum Fourier Transform, Quantum Adder <1-bit Adder>, Graycode, Decoder, Toffoli Gate]","[RevLib: [@inproceedings{wille2008revlib,
  title={RevLib: An online resource for reversible functions and reversible circuits},
  author={Wille, Robert and Gro{\ss}e, Daniel and Teuber, Lisa and Dueck, Gerhard W and Drechsler, Rolf},
  booktitle={38th International Symposium on Multiple Valued Logic (ismvl 2008)},
  pages={220--225},
  year={2008},
  organization={IEEE}
}], https://www.revlib.org/]",[Quantum algorithms and subroutines:7],[None],[None],[Y],"[3, 4, 5, 6, 7, 8, 9, 10]","[Specific: [Single-qubit gates: 12,14,16,18,24,0,13,24,40,56,99,9,46,1], [CNOT gates: 4,5,17,21,7,8,18,30,42,90,12,52]]","[5,7,8,15,27,29,31,50,62,69,9,12,14,68]",[N],N/A,N/A,N/A,[Un-specified],[Un-specified],"[Physical hardware],[Noisy simulator]",[Measurement outcome],"[Fixed: 1024, 8192]",[104],[Specification: Classical Outcomes],[Dominant output oracle: Un-specified],"[Percentage of quantum circuits with wrong outputs], [Percentage of effective tests], [Two-qubit gate coverage]",[Circuit cost],[N],N/A
17.0,QuSBT: search-based testing of quantum programs,"Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat",2022.0,10.1145/3510454.3516839,Proceedings of the ACM/IEEE 44th International Conference on Software Engineering: Companion Proceedings,https://doi.org/10.1145/3510454.3516839,Association for Computing Machinery,"Generating a test suite for a quantum program such that it has the maximum number of failing tests is an optimization problem. For such optimization, search-based testing has shown promising results in the context of classical programs. To this end, we present a test generation tool for quantum programs based on a genetic algorithm, called QuSBT (Search-based Testing of Quantum Programs). QuSBT automates the testing of quantum programs, with the aim of finding a test suite having the maximum number of failing test cases. QuSBT utilizes IBM's Qiskit as the simulation framework for quantum programs. We present the tool architecture in addition to the implemented methodology (i.e., the encoding of the search individual, the definition of the fitness function expressing the search problem, and the test assessment w.r.t. two types of failures). Finally, we report results of the experiments in which we tested a set of faulty quantum programs with QuSBT to assess its effectiveness. Repository (code and experimental results): https://github.com/Simula-COMPLEX/qusbt-toolVideo: https://youtu.be/3apRCtluAn4","@inproceedings{10.1145/3510454.3516839,
  year = {2022},
  url = {https://doi.org/10.1145/3510454.3516839},
  title = {QuSBT: search-based testing of quantum programs},
  series = {ICSE '22},
  publisher = {Association for Computing Machinery},
  pages = {173–177},
  numpages = {5},
  location = {Pittsburgh, Pennsylvania},
  keywords = {genetic algorithms, quantum programs, search-based testing},
  isbn = {9781450392235},
  doi = {10.1145/3510454.3516839},
  booktitle = {Proceedings of the ACM/IEEE 44th International Conference on Software Engineering: Companion Proceedings},
  author = {Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat},
  address = {New York, NY, USA},
  abstract = {Generating a test suite for a quantum program such that it has the maximum number of failing tests is an optimization problem. For such optimization, search-based testing has shown promising results in the context of classical programs. To this end, we present a test generation tool for quantum programs based on a genetic algorithm, called QuSBT (Search-based Testing of Quantum Programs). QuSBT automates the testing of quantum programs, with the aim of finding a test suite having the maximum number of failing test cases. QuSBT utilizes IBM's Qiskit as the simulation framework for quantum programs. We present the tool architecture in addition to the implemented methodology (i.e., the encoding of the search individual, the definition of the fitness function expressing the search problem, and the test assessment w.r.t. two types of failures). Finally, we report results of the experiments in which we tested a set of faulty quantum programs with QuSBT to assess its effectiveness. Repository (code and experimental results): https://github.com/Simula-COMPLEX/qusbt-toolVideo: https://youtu.be/3apRCtluAn4},
}",[Y],[Y],[International Conference on Software Engineering (ICSE)],[Conference],[Software testing],"[Quantum algorithms and subroutines:Bernstein-Vazirani Algorithm, Simon's Algorithm, Quantum Random Access Memory, Quantum Fourier Transform <Inverse Quantum Fourier Transform>, Quantum Conditional Execution, Add Squared Algorithm]",[Un-specified],[Quantum algorithms and subroutines:6],[Mutation operators: Add gate],[Mutants: 30],[N],"[10, 7, 9, 10, 10, 10]",[Total: From 15 to 60],"[3, 5, 12, 56, 20, 38]",[Y],[Random search],[Naivety],"[Mann-Whitney U test: $p$-value, Vargha and Delaney's $\hat{A}_{12}$ statistics]",[Initial quantum states: Computational basis states],"[50, 7, 26, 50, 50, 50]",[Ideal simulator],[Measurement outcome],[Adaptive: the number of possible outputs for a specific input multiplied by 100],[30],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle:Pearson's chi-square test]",[Number of Failed Tests],"[Simulation time], [Execution time of the search]",[Y],[GitHub: https://github.com/Simula-COMPLEX/qusbt-tool]
20.0,Origin program output test generation for quantum programs with multi-objective search,"Wang, Xinyi and Yu, Tongxuan and Arcaini, Paolo and Yue, Tao and Ali, Shaukat",2022.0,10.1145/3512290.3528869,Proceedings of the Genetic and Evolutionary Computation Conference,https://doi.org/10.1145/3512290.3528869,Association for Computing Machinery,"Mutation testing is often used for designing new tests, and involves changing a program in minor ways, which results in mutated versions of the program, i.e., mutants. An effective test suite should find faults (or kill mutants) with a minimum number of test cases, to save resources required for executing test cases. In this paper, in the context of mutation testing for quantum programs, we present a multi-objective and search-based approach (MutTG) to generate the minimum number of test cases killing as many mutants as possible. MutTG tries to estimate the likelihood that a mutant is equivalent, and uses this as a discount factor in the fitness definition to avoid keeping on trying to kill mutants that cannot be killed. We employed NSGA-II as the multi-objective search algorithm. Then, we compared MutTG with another version of the approach that does not use the discount factor in its fitness definition, and with random search (RS), over a set of open-source quantum programs and their mutants of varying complexity. Results show that the discount factor does indeed help in guiding the test generation, as the approach with the discount factor performs better than the one without it.","@inproceedings{10.1145/3512290.3528869,
  year = {2022},
  url = {https://doi.org/10.1145/3512290.3528869},
  title = {Origin program output test generation for quantum programs with multi-objective search},
  series = {GECCO '22},
  publisher = {Association for Computing Machinery},
  pages = {1345–1353},
  numpages = {9},
  location = {Boston, Massachusetts},
  keywords = {genetic algorithms, mutation testing, quantum programs, search-based testing},
  isbn = {9781450392372},
  doi = {10.1145/3512290.3528869},
  booktitle = {Proceedings of the Genetic and Evolutionary Computation Conference},
  author = {Wang, Xinyi and Yu, Tongxuan and Arcaini, Paolo and Yue, Tao and Ali, Shaukat},
  address = {New York, NY, USA},
  abstract = {Mutation testing is often used for designing new tests, and involves changing a program in minor ways, which results in mutated versions of the program, i.e., mutants. An effective test suite should find faults (or kill mutants) with a minimum number of test cases, to save resources required for executing test cases. In this paper, in the context of mutation testing for quantum programs, we present a multi-objective and search-based approach (MutTG) to generate the minimum number of test cases killing as many mutants as possible. MutTG tries to estimate the likelihood that a mutant is equivalent, and uses this as a discount factor in the fitness definition to avoid keeping on trying to kill mutants that cannot be killed. We employed NSGA-II as the multi-objective search algorithm. Then, we compared MutTG with another version of the approach that does not use the discount factor in its fitness definition, and with random search (RS), over a set of open-source quantum programs and their mutants of varying complexity. Results show that the discount factor does indeed help in guiding the test generation, as the approach with the discount factor performs better than the one without it.},
}",[Y],[Y],[Genetic and Evolutionary Computation Conference (GECCO)],[Conference],[Software testing],"[Quantum algorithms and subroutines:Bernstein-Vazirani Algorithm, Quantum Random Access Memory, Quantum Fourier Transform <Inverse Quantum Fourier Transform>, Quantum Conditional Execution, Add Squared Algorithm]",[Un-specified],[Quantum algorithms and subroutines:5],[Un-specified],[Versions: 20],[N],"[8,9,10]","[Total:39,24,25,60,15]","[37,3,20,56,12]",[Y],"[Random search], [MutTG without the discount factor applied]","[Naivety], [Ablation]","[Mann-Whitney U test: $p$-value, Vargha and Delaney's $\hat{A}_{12}$ statistics]",[Initial quantum states: Computational basis states],[Un-specified],[Ideal simulator],[Measurement outcome],[Adaptive: the number of possible outputs for a specific input multiplied by 100],[30],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle:Pearson's chi-square test]","[Hypervolume], [$MNNKM$], [$TSS_{MNNKM}$]",[Un-specified],[Y],[GitHub: https://github.com/Simula-COMPLEX/MutTG-paper]
21.0,Generating failing test suites for quantum programs with search,"Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat",2021.0,10.1007/978-3-030-88106-1_2,International symposium on search based software engineering,https://link.springer.com/chapter/10.1007/978-3-030-88106-1_2,Springer,"Testing quantum programs requires systematic, automated, and intelligent methods due to their inherent complexity, such as their superposition and entanglement. To this end, we present a search-based approach, called Quantum Search-Based Testing (QuSBT), for automatically generating test suites of a given size depending on available testing budget, with the aim of maximizing the number of failing test cases in the test suite. QuSBT consists of definitions of the problem encoding, failure types, test assessment with statistical tests, fitness function, and test case generation with a Genetic Algorithm (GA). To empirically evaluate QuSBT, we compared it with Random Search (RS) by testing six quantum programs. We assessed the effectiveness of QuSBT and RS with 30 carefully designed faulty versions of the six quantum programs. Results show that QuSBT provides a viable solution for testing quantum programs, and achieved a significant improvement over RS in 87% of the faulty programs, and no significant difference in the rest of 13% of the faulty programs.","@inproceedings{10.1145/3520304.3534067,
  year = {2022},
  url = {https://doi.org/10.1145/3520304.3534067},
  title = {Generating failing test suites for quantum programs with search},
  author={Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat},
  booktitle={International symposium on search based software engineering},
  pages={9--25},
  year={2021},
  organization={Springer},  
  abstract = {Testing quantum programs requires systematic, automated, and intelligent methods due to their inherent complexity, such as their superposition and entanglement. To this end, we present a search-based approach, called Quantum Search-Based Testing (QuSBT), for automatically generating test suites of a given size depending on available testing budget, with the aim of maximizing the number of failing test cases in the test suite. QuSBT consists of definitions of the problem encoding, failure types, test assessment with statistical tests, fitness function, and test case generation with a Genetic Algorithm (GA). To empirically evaluate QuSBT, we compared it with Random Search (RS) by testing six quantum programs. We assessed the effectiveness of QuSBT and RS with 30 carefully designed faulty versions of the six quantum programs. Results show that QuSBT provides a viable solution for testing quantum programs, and achieved a significant improvement over RS in 87% of the faulty programs, and no significant difference in the rest of 13% of the faulty programs.}
}",[Y],[Y],[International Symposium on Search Based Software Engineering (SSBSE)],[Conference],[Software testing],"[Quantum algorithms and subroutines:Bernstein-Vazirani Algorithm, Simon's Algorithm,Quantum Random Access Memory, Quantum Fourier Transform <Inverse Quantum Fourier Transform>, Quantum Conditional Execution, Add Squared Algorithm]",[Un-specified],[Quantum algorithms and subroutines:6],"[Mutation operators: Add gate, Replace gate]",[Versions: 30],[N],"[7,9,10]","[Total:41,30,25,60,15,56]","[38,3,20,56,12,5]",[Y],[Random search],[Naivety],"[Mann-Whitney U test: $p$-value, Vargha and Delaney's $\hat{A}_{12}$ statistics]",[Initial quantum states: Computational basis states],"[50,26,7]",[Ideal simulator],[Measurement outcome],[Adaptive: the number of possible outputs for a specific input multiplied by 100],[30],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle:Pearson's chi-square test]",[Number of failing tests],[Un-specified],[Y],[GitHub:https://github.com/Simula-COMPLEX/qusbt/]
24.0,Metamorphic testing of oracle quantum programs,"Abreu, Rui and Fernandes, Jo\~{a}o Paulo and Llana, Luis and Tavares, Guilherme",2023.0,10.1145/3528230.3529189,2022 IEEE/ACM 3rd International Workshop on Quantum Software Engineering (Q-SE),https://doi.org/10.1145/3528230.3529189,Association for Computing Machinery,"Quantum Computing is regarded with a growing sense of excite-ment and expectation. While the preliminary evidences of its prac-tical interest accumulate, there are numerous challenges that must be addressed before quantum computing can reach generalized adoption and realize its full potential. One such challenge concerns assessing whether a quantum program is correct, namely in the sense that it implements the desired functionality. In the classical realm, program testing is a well-established approach to find de-fects in programs. While this approach should inspire quantum software development, porting classical testing techniques to the quantum world is by no means trivial. We propose a novel approach to test quantum programs. Our approach is based on the use of metamorphic relations, which allows us to overcome the well-known quantum measurement problem. We describe a series of exploratory experiments whose results provide evidence of the usefulness of our approach.","@inproceedings{10.1145/3528230.3529189,
  year = {2023},
  url = {https://doi.org/10.1145/3528230.3529189},
  title = {Metamorphic testing of oracle quantum programs},
  series = {Q-SE '22},
  publisher = {Association for Computing Machinery},
  pages = {16–23},
  numpages = {8},
  month = {May},
  location = {Pittsburgh, Pennsylvania},
  keywords = {Quantum computing,Conferences,Software,Testing,Software engineering,Metamorphic Testing,Quantum Testing,Quantum Software Qual-ity},
  isbn = {9781450393355},
  doi = {10.1145/3528230.3529189},
  booktitle = {2022 IEEE/ACM 3rd International Workshop on Quantum Software Engineering (Q-SE)},
  author = {Abreu, Rui and Fernandes, Jo\~{a}o Paulo and Llana, Luis and Tavares, Guilherme},
  address = {New York, NY, USA},
  abstract = {Quantum Computing is regarded with a growing sense of excite-ment and expectation. While the preliminary evidences of its prac-tical interest accumulate, there are numerous challenges that must be addressed before quantum computing can reach generalized adoption and realize its full potential. One such challenge concerns assessing whether a quantum program is correct, namely in the sense that it implements the desired functionality. In the classical realm, program testing is a well-established approach to find de-fects in programs. While this approach should inspire quantum software development, porting classical testing techniques to the quantum world is by no means trivial. We propose a novel approach to test quantum programs. Our approach is based on the use of metamorphic relations, which allows us to overcome the well-known quantum measurement problem. We describe a series of exploratory experiments whose results provide evidence of the usefulness of our approach.},
}",[Y],[Y],[International Workshop on Quantum Software Engineering (Q-SE)],[Workshop],[Software testing],[Quantum algorithms and subroutines: Grover Search],[Un-specified],[Quantum algorithms and subroutines:1],[Un-specified],[Versions: 1],[Y],"[2,3]",[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Initial quantum states: Computational basis states],[Un-specified],[Ideal simulator],[Measurement outcome],[Un-specified],[Un-specified],[Property: Metamorphic relation],[Property-based oracle: None],"[Measurement probabilities], [Number of failing tests]",[Un-specified],[Y],[GitHub: https://github.com/LuisLlana/metamorphic_testing/]
27.0,Asserting the correctness of Shor implementations using metamorphic testing,"Costa, Nuno and Fernandes, Jo\~{a}o Paulo and Abreu, Rui",2022.0,10.1145/3549036.3562062,Proceedings of the 1st International Workshop on Quantum Programming for Software Engineering,https://doi.org/10.1145/3549036.3562062,Association for Computing Machinery,"Quantum computing is infused with an increased sense of anticipation and excitement. However, several obstacles need to be overcome before quantum computing can be widely adopted. One of these is determining whether or not a quantum program is behaving according to the expectation. There are several tried-and-true methods for identifying program flaws in the traditional world, but it is far from simple to adapt them to the quantum realm. In this paper, we explore Metamorphic Testing as a promising avenue. We explore this avenue on the well-known Shor's Algorithm, and show how it can be used to verify the validity of this testing approach on Quantum algorithms and subroutines.","@inproceedings{10.1145/3549036.3562062,
  year = {2022},
  url = {https://doi.org/10.1145/3549036.3562062},
  title = {Asserting the correctness of Shor implementations using metamorphic testing},
  series = {QP4SE 2022},
  publisher = {Association for Computing Machinery},
  pages = {32–36},
  numpages = {5},
  location = {Singapore, Singapore},
  keywords = {metamorphic testing, quantum computing, quantum testing},
  isbn = {9781450394581},
  doi = {10.1145/3549036.3562062},
  booktitle = {Proceedings of the 1st International Workshop on Quantum Programming for Software Engineering},
  author = {Costa, Nuno and Fernandes, Jo\~{a}o Paulo and Abreu, Rui},
  address = {New York, NY, USA},
  abstract = {Quantum computing is infused with an increased sense of anticipation and excitement. However, several obstacles need to be overcome before quantum computing can be widely adopted. One of these is determining whether or not a quantum program is behaving according to the expectation. There are several tried-and-true methods for identifying program flaws in the traditional world, but it is far from simple to adapt them to the quantum realm. In this paper, we explore Metamorphic Testing as a promising avenue. We explore this avenue on the well-known Shor's Algorithm, and show how it can be used to verify the validity of this testing approach on Quantum algorithms and subroutines.},
}",[Y],[Y],[International Workshop on Quantum Programming for Software Engineering (QP4SE)],[Workshop],[Software testing],[Quantum algorithms and subroutines: Shor's Algorithm],"[Qiskit textbook: [Un-specified], https://qiskit.org/textbook/ch-algorithms/shor.html], [O'reilly: [@book{johnston2019programming,
  title={Programming quantum computers: essential algorithms and code samples},
  author={Johnston, Eric R and Harrigan, Nic and Gimeno-Segovia, Mercedes},
  year={2019},
  publisher={O'Reilly Media}
}], https://oreilly-qc.github.io/]",[Quantum algorithms and subroutines:1],[Un-specified],[Versions: 4],[N],[Un-specified],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Classical inputs: Numbers],[9],[Ideal simulator],[Measurement outcome],[Fixed: 100],[Un-specified],[Property: Metamorphic relation],[Property-based oracle: None],[Number of failed iterations],[Un-specified],[Y],[GitHub: https://github.com/biromiro/feup-gulbenkian-qc-mt]
31.0,Locating Buggy Segments in Quantum Program Debugging,"Sato, Naoto and Katsube, Ryota",2024.0,10.1145/3639476.3639761,Proceedings of the 2024 ACM/IEEE 44th International Conference on Software Engineering: New Ideas and Emerging Results,https://doi.org/10.1145/3639476.3639761,Association for Computing Machinery,"When a bug is detected by testing a quantum program on a quantum computer, we want to determine its location to fix it. To locate the bug, the quantum program is divided into several segments, and each segment is tested. However, to prepare a quantum state that is input to a segment, it is necessary to execute all the segments ahead of that segment in a quantum computer. This means that the cost of testing each segment depends on its location. We can also locate a buggy segment only if it is confirmed that there are no bugs in all segments ahead of that buggy segment. Since a quantum program is tested statistically on the basis of measurement results, there is a tradeoff between testing accuracy and cost. Although these characteristics are unique to quantum programs and complicate locating bugs, they have not been investigated. We suggest for the first time that these characteristics should be considered to efficiently locate bugs. We are also the first to propose a bug-locating method that takes these characteristics into account. The results from experiments indicate that the bug-locating cost, represented as the number of executed quantum gates, can be reduced with the proposed method compared with naive methods.","@inproceedings{10.1145/3639476.3639761,
  year = {2024},
  url = {https://doi.org/10.1145/3639476.3639761},
  title = {Locating Buggy Segments in Quantum Program Debugging},
  series = {ICSE-NIER'24},
  publisher = {Association for Computing Machinery},
  pages = {26–31},
  numpages = {6},
  month = {April},
  location = {Lisbon, Portugal},
  keywords = {Quantum computing,Costs,Accuracy,Computer bugs,Debugging,Quantum state,Logic gates,Testing,Software engineering},
  issn = {2832-7632},
  isbn = {9798400705007},
  doi = {10.1145/3639476.3639761},
  booktitle = {Proceedings of the 2024 ACM/IEEE 44th International Conference on Software Engineering: New Ideas and Emerging Results},
  author = {Sato, Naoto and Katsube, Ryota},
  address = {New York, NY, USA},
  abstract = {When a bug is detected by testing a quantum program on a quantum computer, we want to determine its location to fix it. To locate the bug, the quantum program is divided into several segments, and each segment is tested. However, to prepare a quantum state that is input to a segment, it is necessary to execute all the segments ahead of that segment in a quantum computer. This means that the cost of testing each segment depends on its location. We can also locate a buggy segment only if it is confirmed that there are no bugs in all segments ahead of that buggy segment. Since a quantum program is tested statistically on the basis of measurement results, there is a tradeoff between testing accuracy and cost. Although these characteristics are unique to quantum programs and complicate locating bugs, they have not been investigated. We suggest for the first time that these characteristics should be considered to efficiently locate bugs. We are also the first to propose a bug-locating method that takes these characteristics into account. The results from experiments indicate that the bug-locating cost, represented as the number of executed quantum gates, can be reduced with the proposed method compared with naive methods.},
}",[Y],[Y],[International Conference on Software Engineering: New Ideas and Emerging Results (ICSE-NIER)],[Conference],[Fault localization],[Artificial programs],[Un-specified],[Artificial programs:100],[Un-specified],[Un-specified],[Y],"[2,5,10]","[Total:50,100,150]",[Un-specified],[Y],"[Naive linear search], [Naive binary search]","[Naivety], [Naivety]",N/A,[Un-specified],[Un-specified],[Ideal simulator],[Measurement outcome],[Un-specified],[Un-specified],[Specification: Probability distribution],[Output probability oracle: Pearson's chi-square test],[Success probability],[Search cost],[N],N/A
33.0,Delta Debugging for Property-Based Regression Testing of Quantum Programs,"Pontolillo, Gabriel Joseph and Mousavi, Mohammad Reza",2024.0,10.1145/3643667.3648219,Proceedings of the 5th ACM/IEEE International Workshop on Quantum Software Engineering,https://doi.org/10.1145/3643667.3648219,Association for Computing Machinery,"Manually debugging quantum programs is a difficult and time-intensive process. In this paper, we introduce an automated debugging technique, based on delta debugging and property-based testing, for quantum programs. Our technique automatically identifies the changes made within an update to a quantum program that cause a property-based regression test to fail. To evaluate our technique, we inject faults and semantic preserving changes into three Quantum algorithms and subroutines. We discuss the viability and efficacy of our approach after measuring the percentage of faults and semantic preserving changes. Our results indicate that our method has a high true positive (called sensitivity) and true negative rate (called specificity) and is robust in terms of the amount of changes introduced to the program. Moreover, the sensitivity of the method increases significantly with the number of properties. While the specificity remains stable when increasing the number of properties and inputs.","@inproceedings{10.1145/3643667.3648219,
  year = {2024},
  url = {https://doi.org/10.1145/3643667.3648219},
  title = {Delta Debugging for Property-Based Regression Testing of Quantum Programs},
  series = {Q-SE 2024},
  publisher = {Association for Computing Machinery},
  pages = {1–8},
  numpages = {8},
  location = {Lisbon, Portugal},
  isbn = {9798400705700},
  doi = {10.1145/3643667.3648219},
  booktitle = {Proceedings of the 5th ACM/IEEE International Workshop on Quantum Software Engineering},
  author = {Pontolillo, Gabriel Joseph and Mousavi, Mohammad Reza},
  address = {New York, NY, USA},
  abstract = {Manually debugging quantum programs is a difficult and time-intensive process. In this paper, we introduce an automated debugging technique, based on delta debugging and property-based testing, for quantum programs. Our technique automatically identifies the changes made within an update to a quantum program that cause a property-based regression test to fail. To evaluate our technique, we inject faults and semantic preserving changes into three Quantum algorithms and subroutines. We discuss the viability and efficacy of our approach after measuring the percentage of faults and semantic preserving changes. Our results indicate that our method has a high true positive (called sensitivity) and true negative rate (called specificity) and is robust in terms of the amount of changes introduced to the program. Moreover, the sensitivity of the method increases significantly with the number of properties. While the specificity remains stable when increasing the number of properties and inputs.},
}",[Y],[Y],[International Workshop on Quantum Software Engineering (Q-SE)],[Workshop],[Software testing],"[Quantum algorithms and subroutines: Quantum Fourier Transform, Quantum Teleportation, Quantum Phase Estimation]",[Un-specified],[Quantum algorithms and subroutines:3],[Un-specified],[Versions: 9],[N],[Un-specified],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Classical inputs: Oracle],"[1,2,4]",[Un-specified],[Measurement outcome],[Un-specified],[50],[Property: General property],[Property-based oracle:Fisher's exact test],"[Percentage of faults identified], [Percentage of semantic preserving changes removed]",[Un-specified],[Y],"[Figshare: https://figshare.com/articles/software/Delta_Debugging_for_Property-Based_Regression_Testing_of_Quantum_Programs/25075154?file=44241593], [GitHub: https://github.com/GabrielPontolillo/ddregression]"
35.0,Gate Branch Coverage: A Metric for Quantum Software Testing,"Fortunato, Daniel and Campos, Jos\'{e} and Abreu, Rui",2024.0,10.1145/3663531.3664753,"PROCEEDINGS OF THE 1ST ACM INTERNATIONAL WORKSHOP ON QUANTUM SOFTWARE ENGINEERING:THE NEXT EVOLUTION, QSE-NE 2024",https://doi.org/10.1145/3663531.3664753,Association for Computing Machinery,"The inherent lack of technologies and knowledge from software developers about the intricacies of quantum physics constitutes a heavy hindrance in the development of correct quantum software. Therefore, quantum computing testing techniques are currently under heavy research. This paper proposes a new testing metric, Gate Branch Coverage. This metric aims to provide insight into the verification process status of quantum programs and enhance the quantum testing process overall. Gate Branch Coverage explores the properties of quantum controlled-type gates, measuring their number of exercised branches during the execution of quantum programs.","@inproceedings{10.1145/3663531.3664753,
  year = {2024},
  url = {https://doi.org/10.1145/3663531.3664753},
  title = {Gate Branch Coverage: A Metric for Quantum Software Testing},
  series = {QSE-NE 2024},
  publisher = {Association for Computing Machinery},
  pages = {15–18},
  numpages = {4},
  location = {Porto de Galinhas, Brazil},
  keywords = {Quantum Computing, Quantum Gate Branch Coverage, Quantum Software Testing},
  isbn = {9798400706738},
  doi = {10.1145/3663531.3664753},
  booktitle = {PROCEEDINGS OF THE 1ST ACM INTERNATIONAL WORKSHOP ON QUANTUM SOFTWARE ENGINEERING:THE NEXT EVOLUTION, QSE-NE 2024},
  author = {Fortunato, Daniel and Campos, Jos\'{e} and Abreu, Rui},
  address = {New York, NY, USA},
  abstract = {The inherent lack of technologies and knowledge from software developers about the intricacies of quantum physics constitutes a heavy hindrance in the development of correct quantum software. Therefore, quantum computing testing techniques are currently under heavy research. This paper proposes a new testing metric, Gate Branch Coverage. This metric aims to provide insight into the verification process status of quantum programs and enhance the quantum testing process overall. Gate Branch Coverage explores the properties of quantum controlled-type gates, measuring their number of exercised branches during the execution of quantum programs.},
}",[Y],[Y],[International Workshop on Quantum Software Engineering: The Next Evolution (QSE-NE)],[Workshop],[Software testing],[Artificial programs],[Un-specified],[Artificial programs:1],[None],[None],[N],[2],[Total: 2],[1],[N],N/A,N/A,N/A,[Initial quantum states: Separable states modelled by Bloch sphere],[1],[Ideal simulator],[Measurement outcome],[Fixed: 100],[Un-specified],[Un-specified],[Un-specified],[Gate branch coverage],[Un-specified],[N],N/A
36.0,QuanTest: Entanglement-Guided Testing of Quantum Neural Network Systems,"Shi, Jinjing and Xiao, Zimeng and Shi, Heyuan and Jiang, Yu and Li, Xuelong",2025.0,10.1145/3688840,ACM Trans. Softw. Eng. Methodol.,https://doi.org/10.1145/3688840,Association for Computing Machinery,"Quantum Neural Network (QNN) combines the deep learning (DL) principle with the fundamental theory of quantum mechanics to achieve machine learning tasks with quantum acceleration. Recently, QNN systems have been found to manifest robustness issues similar to classical DL systems. There is an urgent need for ways to test their correctness and security. However, QNN systems differ significantly from traditional quantum software and classical DL systems, posing critical challenges for QNN testing. These challenges include the inapplicability of traditional quantum software testing methods to QNN systems due to differences in programming paradigms and decision logic representations, the dependence of quantum test sample generation on perturbation operators, and the absence of effective information in quantum neurons. In this article, we propose QuanTest, a quantum entanglement-guided adversarial testing framework to uncover potential erroneous behaviors in QNN systems. We design a quantum entanglement adequacy criterion to quantify the entanglement acquired by the input quantum states from the QNN system, along with two similarity metrics to measure the proximity of generated quantum adversarial examples to the original inputs. Subsequently, QuanTest formulates the problem of generating test inputs that maximize the quantum entanglement adequacy and capture incorrect behaviors of the QNN system as a joint optimization problem and solves it in a gradient-based manner to generate quantum adversarial examples. Experimental results demonstrate that QuanTest possesses the capability to capture erroneous behaviors in QNN systems (generating 67.48–96.05% more high-quality test samples than the random noise under the same perturbation size constraints). The entanglement-guided approach proves effective in adversarial testing, generating more adversarial examples (maximum increase reached 21.32%).","@article{10.1145/3688840,
  year = {2025},
  volume = {34},
  url = {https://doi.org/10.1145/3688840},
  title = {QuanTest: Entanglement-Guided Testing of Quantum Neural Network Systems},
  publisher = {Association for Computing Machinery},
  numpages = {32},
  number = {2},
  month = {January},
  keywords = {Quantum neural network, deep neural network, adversarial testing, quantum entanglement},
  journal = {ACM Trans. Softw. Eng. Methodol.},
  issue_date = {February 2025},
  issn = {1049-331X},
  doi = {10.1145/3688840},
  author = {Shi, Jinjing and Xiao, Zimeng and Shi, Heyuan and Jiang, Yu and Li, Xuelong},
  articleno = {48},
  address = {New York, NY, USA},
  abstract = {Quantum Neural Network (QNN) combines the deep learning (DL) principle with the fundamental theory of quantum mechanics to achieve machine learning tasks with quantum acceleration. Recently, QNN systems have been found to manifest robustness issues similar to classical DL systems. There is an urgent need for ways to test their correctness and security. However, QNN systems differ significantly from traditional quantum software and classical DL systems, posing critical challenges for QNN testing. These challenges include the inapplicability of traditional quantum software testing methods to QNN systems due to differences in programming paradigms and decision logic representations, the dependence of quantum test sample generation on perturbation operators, and the absence of effective information in quantum neurons. In this article, we propose QuanTest, a quantum entanglement-guided adversarial testing framework to uncover potential erroneous behaviors in QNN systems. We design a quantum entanglement adequacy criterion to quantify the entanglement acquired by the input quantum states from the QNN system, along with two similarity metrics to measure the proximity of generated quantum adversarial examples to the original inputs. Subsequently, QuanTest formulates the problem of generating test inputs that maximize the quantum entanglement adequacy and capture incorrect behaviors of the QNN system as a joint optimization problem and solves it in a gradient-based manner to generate quantum adversarial examples. Experimental results demonstrate that QuanTest possesses the capability to capture erroneous behaviors in QNN systems (generating 67.48–96.05% more high-quality test samples than the random noise under the same perturbation size constraints). The entanglement-guided approach proves effective in adversarial testing, generating more adversarial examples (maximum increase reached 21.32%).},
}",[Y],[Y],[ACM Transactions on Software Engineering and Methodology (TOSEM)],[Journal],[Software testing],"[Quantum learning-based models: Quantum Circuit Learning, Circuit-centric Quantum Classfiers, Quantum Convolutional Neural Network]",[Un-specified],[Quantum learning-based models: 3],[Imperfect models],[Models: 9],[Y],"[8, 10]","[Total: 200,160,134]",[Un-specified],[Y],"[SimBAy], [Random coherent noise]","[SOTA],[Naivety]",[Un-specified],[Classical inputs: Images],[600],[Ideal simulator],[Measurement outcome],[Varied: From 10 to $10^5$],"[5, 10]",[Specification: True label],[Un-specified],"[Quantum entanglement adequacy], [Average fidelity measure], [Average trace distance], [Test sample generation rate], [Accuracy], [Precision], [Recall], [F1 score], [Error rate]",[Sample cost],[Y],[GitHub: https://github.com/am0x00/QuanTest]
37.0,Automatic Test Pattern Generation for Robust Quantum Circuit Testing,"Chen, Kean and Ying, Mingsheng",2024.0,10.1145/3689333,ACM Trans. Des. Autom. Electron. Syst.,https://doi.org/10.1145/3689333,Association for Computing Machinery,"Quantum circuit testing is essential for detecting potential faults in realistic quantum devices, while the testing process itself also suffers from the inexactness and unreliability of quantum operations. This article alleviates the issue by proposing a novel framework of automatic test pattern generation (ATPG) for robust testing of logical quantum circuits. We introduce the stabilizer projector decomposition (SPD) for representing the quantum test pattern and construct the test application (i.e., state preparation and measurement) using Clifford-only circuits, which are rather robust and efficient as evidenced in the fault-tolerant quantum computation. However, it is generally hard to generate SPDs due to the exponentially growing number of the stabilizer projectors. To circumvent this difficulty, we develop an SPD generation algorithm, as well as several acceleration techniques that can exploit both locality and sparsity in generating SPDs. The effectiveness of our algorithms are validated by (1) theoretical guarantees under reasonable conditions and (2) experimental results on commonly used benchmark circuits, such as Quantum Fourier Transform (QFT), Quantum Volume (QV), and Bernstein-Vazirani (BV) in IBM Qiskit.","@article{10.1145/3689333,
  year = {2024},
  volume = {29},
  url = {https://doi.org/10.1145/3689333},
  title = {Automatic Test Pattern Generation for Robust Quantum Circuit Testing},
  publisher = {Association for Computing Machinery},
  numpages = {36},
  number = {6},
  month = {September},
  keywords = {Quantum circuit, circuit testing, ATPG},
  journal = {ACM Trans. Des. Autom. Electron. Syst.},
  issue_date = {November 2024},
  issn = {1084-4309},
  doi = {10.1145/3689333},
  author = {Chen, Kean and Ying, Mingsheng},
  articleno = {98},
  address = {New York, NY, USA},
  abstract = {Quantum circuit testing is essential for detecting potential faults in realistic quantum devices, while the testing process itself also suffers from the inexactness and unreliability of quantum operations. This article alleviates the issue by proposing a novel framework of automatic test pattern generation (ATPG) for robust testing of logical quantum circuits. We introduce the stabilizer projector decomposition (SPD) for representing the quantum test pattern and construct the test application (i.e., state preparation and measurement) using Clifford-only circuits, which are rather robust and efficient as evidenced in the fault-tolerant quantum computation. However, it is generally hard to generate SPDs due to the exponentially growing number of the stabilizer projectors. To circumvent this difficulty, we develop an SPD generation algorithm, as well as several acceleration techniques that can exploit both locality and sparsity in generating SPDs. The effectiveness of our algorithms are validated by (1) theoretical guarantees under reasonable conditions and (2) experimental results on commonly used benchmark circuits, such as Quantum Fourier Transform (QFT), Quantum Volume (QV), and Bernstein-Vazirani (BV) in IBM Qiskit.},
}",[Y],[Y],[ACM Transactions on Design Automation of Electronic Systems (TODAES)],[Journal],[Software testing],"[Quantum algorithms and subroutines: Quantum Fourier Transform, Quantum Volume, Bernstein-Vazirani Algorithm]",[Un-specified],[Quantum algorithms and subroutines:3],[Mutation operators: Remove gate],[Un-specified],[Y],"[3,5,6,7,8,9,10,7,100]","[Total: 18,55,235,135,201,29,299], [Specific: [Non-Clifford gates: 9,30,135,105,156,0]]","[14,30,70,43,12,102]",[Y],[Direct method with the Clifford + Pauli rotation gate set],[Ablation],[Un-specified],[Initial quantum states: Un-specified]; [Measurement operators: Helstrom measurement operators],[Un-specified],[Ideal simulator],[Measurement outcome],[Un-specified],[100],[Specification: Quantum operator],[Un-specified],"[Product of the SPD 1-norm], [Number of true positives], [Number of true negatives], [Number of false positives], [Number of false negatives], [Precision], [Recall], [Accuracy]","[Sparsity of the generated SPD], [Size of Clifford circuits], [Depth of Clifford circuits]",[N],[GitHub: https://github.com/cccorn/Q-ATPG]
38.0,Statistical Testing of Quantum Programs via Fixed-Point Amplitude Amplification,"Kang, Chan Gu and Lee, Joonghoon and Oh, Hakjoo",2024.0,10.1145/3689716,Proc. ACM Program. Lang.,https://doi.org/10.1145/3689716,Association for Computing Machinery,"We present a new technique for accelerating quantum program testing. Given a quantum circuit with an input/output specification, our goal is to check whether executing the program on the input state produces the expected output. In quantum computing, however, it is impossible to directly check the equivalence of the two quantum states. Instead, we rely on statistical testing, which involves repeated program executions, state measurements, and subsequent comparisons with the specified output. To guarantee a high level of assurance, however, this method requires an extensive number of measurements. In this paper, we propose a solution to alleviate this challenge by adapting Fixed-Point Amplitude Amplification (FPAA) for quantum program testing. We formally present our technique, demonstrate its ability to reduce the required number of measurements as well as runtime cost without sacrificing the original statistical guarantee, and showcase its runtime effectiveness through case studies.","@article{10.1145/3689716,
  year = {2024},
  volume = {8},
  url = {https://doi.org/10.1145/3689716},
  title = {Statistical Testing of Quantum Programs via Fixed-Point Amplitude Amplification},
  publisher = {Association for Computing Machinery},
  numpages = {25},
  number = {OOPSLA2},
  month = {October},
  keywords = {Quantum Computing, Quantum Programming, Testing, Verification},
  journal = {Proc. ACM Program. Lang.},
  issue_date = {October 2024},
  doi = {10.1145/3689716},
  author = {Kang, Chan Gu and Lee, Joonghoon and Oh, Hakjoo},
  articleno = {276},
  address = {New York, NY, USA},
  abstract = {We present a new technique for accelerating quantum program testing. Given a quantum circuit with an input/output specification, our goal is to check whether executing the program on the input state produces the expected output. In quantum computing, however, it is impossible to directly check the equivalence of the two quantum states. Instead, we rely on statistical testing, which involves repeated program executions, state measurements, and subsequent comparisons with the specified output. To guarantee a high level of assurance, however, this method requires an extensive number of measurements. In this paper, we propose a solution to alleviate this challenge by adapting Fixed-Point Amplitude Amplification (FPAA) for quantum program testing. We formally present our technique, demonstrate its ability to reduce the required number of measurements as well as runtime cost without sacrificing the original statistical guarantee, and showcase its runtime effectiveness through case studies.},
}",[Y],[Y],"[International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)]",[Conference],[Software testing],[Quantum algorithms and subroutines: Draper Adder <Draper Adder and Doubly Controlled Draper Adder>],[Un-specified],[Quantum algorithms and subroutines:2],[Mutation operators: Add gate],[2],[Y],[4],[Un-specified],[Un-specified],[Y],[SAMPLE],[Naivety],[Un-specified],[Initial quantum states: Computational basis states],[Un-specified],[Ideal simulator],[Measurement outcome],[Adaptive: Mathematically calculated],[Un-specified],[Specification: Quantum state],[Un-specified],[Un-specified],[Reduction in the runtime cost],[Y],[Zenodo: https://zenodo.org/records/13370788]
39.0,Quantum Program Testing Through Commuting Pauli Strings on IBM's Quantum Computers,"Muqeet, Asmar and Ali, Shaukat and Arcaini, Paolo",2024.0,10.1145/3691620.3695275,"PROCEEDINGS OF 2024 39TH ACM/IEEE INTERNATIONAL CONFERENCE ON AUTOMATED SOFTWARE ENGINEERING, ASE 2024",https://doi.org/10.1145/3691620.3695275,Association for Computing Machinery,"The most promising applications of quantum computing are centered around solving search and optimization tasks, particularly in fields such as physics simulations, quantum chemistry, and finance. However, the current quantum software testing methods face practical limitations when applied in industrial contexts: (i) they do not apply to quantum programs most relevant to the industry, (ii) they require a full program specification, which is usually not available for these programs, and (iii) they are incompatible with error mitigation methods currently adopted by main industry actors like IBM. To address these challenges, we present QOPS, a novel quantum software testing approach. QOPS introduces a new definition of test cases based on Pauli strings to improve compatibility with different quantum programs. QOPS also introduces a new test oracle that can be directly integrated with industrial APIs such as IBM’s Estimator API and can utilize error mitigation methods for testing on real noisy quantum computers. We also leverage the commuting property of Pauli strings to relax the requirement of having complete program specifications, making QOPS practical for testing complex quantum programs in industrial settings. We empirically evaluate QOPS on 194,982 real quantum programs, demonstrating effective performance in test assessment compared to the state-of-the-art with a perfect F1-score, precision, and recall. Furthermore, we validate the industrial applicability of QOPS by assessing its performance on IBM’s three real quantum computers, incorporating both industrial and open-source error mitigation methods.CCS Concepts• Software and its engineering → Correctness, • Theory of computation → Quantum computation theory, • Computer systems organization → Quantum computing","@inproceedings{10.1145/3691620.3695275,
  year = {2024},
  url = {https://doi.org/10.1145/3691620.3695275},
  title = {Quantum Program Testing Through Commuting Pauli Strings on IBM's Quantum Computers},
  series = {ASE '24},
  publisher = {Association for Computing Machinery},
  pages = {2130–2141},
  numpages = {12},
  month = {Oct},
  location = {Sacramento, CA, USA},
  keywords = {Computers,Software testing,Industries,Quantum computing,Prevention and mitigation,Quantum mechanics,Software,Quantum circuit,Optimization,Software engineering,Software Testing,Test Oracle,Quantum Computing,Pauli Strings},
  issn = {2643-1572},
  isbn = {9798400712487},
  doi = {10.1145/3691620.3695275},
  booktitle = {PROCEEDINGS OF 2024 39TH ACM/IEEE INTERNATIONAL CONFERENCE ON AUTOMATED SOFTWARE ENGINEERING, ASE 2024},
  author = {Muqeet, Asmar and Ali, Shaukat and Arcaini, Paolo},
  address = {New York, NY, USA},
  abstract = {The most promising applications of quantum computing are centered around solving search and optimization tasks, particularly in fields such as physics simulations, quantum chemistry, and finance. However, the current quantum software testing methods face practical limitations when applied in industrial contexts: (i) they do not apply to quantum programs most relevant to the industry, (ii) they require a full program specification, which is usually not available for these programs, and (iii) they are incompatible with error mitigation methods currently adopted by main industry actors like IBM. To address these challenges, we present QOPS, a novel quantum software testing approach. QOPS introduces a new definition of test cases based on Pauli strings to improve compatibility with different quantum programs. QOPS also introduces a new test oracle that can be directly integrated with industrial APIs such as IBM’s Estimator API and can utilize error mitigation methods for testing on real noisy quantum computers. We also leverage the commuting property of Pauli strings to relax the requirement of having complete program specifications, making QOPS practical for testing complex quantum programs in industrial settings. We empirically evaluate QOPS on 194,982 real quantum programs, demonstrating effective performance in test assessment compared to the state-of-the-art with a perfect F1-score, precision, and recall. Furthermore, we validate the industrial applicability of QOPS by assessing its performance on IBM’s three real quantum computers, incorporating both industrial and open-source error mitigation methods.CCS Concepts• Software and its engineering → Correctness, • Theory of computation → Quantum computation theory, • Computer systems organization → Quantum computing},
}",[Y],[Y],[International Conference on Automated Software Engineering (ASE)],[Conference],[Software testing],[Quantum algorithms and subroutines: Un-specified],"[MQT bench: [@article{quetschlich2023mqt,
  title={MQT Bench: Benchmarking software and design automation tools for quantum computing},
  author={Quetschlich, Nils and Burgholzer, Lukas and Wille, Robert},
  journal={Quantum},
  volume={7},
  pages={1062},
  year={2023},
  publisher={Verein zur F{\""o}rderung des Open Access Publizierens in den Quantenwissenschaften}}
], https://www.cda.cit.tum.de/mqtbench/]",[Quantum algorithms and subroutines:18],[Mutation toolings: Muskit],[Mutants: 194982],[N],[From 2 to 10],[Un-specified],[Un-specified],[Y],[Existing test oracle],[SOTA],[Un-specified],[Measurement operators: Pauli strings],[Un-specified],[Physical hardware],[Measurement outcome],[Un-specified],[Un-specified],[Specification: Probability distribution],[Output distribution oracle: Expected expectation],"[F1 score], [Precision], [Recall], [False negatives]",[Un-specified],[Y],[GitHub: https://github.com/AsmarMuqeet/QOPS]
41.0,Practical Design by Contract Framework for Quantum Applications,"Yamaguchi, Masaomi and Yoshioka, Nobukazu and Ishikawa, Fuyuki",2025.0,10.1145/3696630.3731621,Proceedings of the 33rd ACM International Conference on the Foundations of Software Engineering,https://doi.org/10.1145/3696630.3731621,Association for Computing Machinery,"Quantum application development typically involves verifying the construction procedures of quantum applications with a few qubits and running them on actual quantum computers based on the verified procedures. However, existing verification techniques face practical issues, such as the need for human intervention, long verification times, and insufficient descriptions. This study introduces a practical Design by Contract framework for quantum applications, designed for testing and debugging quantum applications on simulators. It allows for writing assertions about the input and output states of quantum circuits constructed by certain procedures and the post-processing of measurement results. The quantum application can be verified quickly by checking these assertions in test cases on simulators. Our framework introduces practical mechanisms for quantum application development. It separates the construction procedure of a quantum application and its assertions through parameter distinction, introduces an evaluation rule for early precondition checking, and reduces assertion-writing effort through assertion reuse mechanisms for inverting quantum circuits and using quantum circuits for qubits in a superposition state. We validated our framework through experiments and surveyed industry quantum computer researchers to assess its effectiveness.","@inproceedings{10.1145/3696630.3731621,
  year = {2025},
  url = {https://doi.org/10.1145/3696630.3731621},
  title = {Practical Design by Contract Framework for Quantum Applications},
  series = {FSE Companion '25},
  publisher = {Association for Computing Machinery},
  pages = {1699–1709},
  numpages = {11},
  location = {Clarion Hotel Trondheim, Trondheim, Norway},
  keywords = {design by contract, testing and debugging, quantum computing},
  isbn = {9798400712760},
  doi = {10.1145/3696630.3731621},
  booktitle = {Proceedings of the 33rd ACM International Conference on the Foundations of Software Engineering},
  author = {Yamaguchi, Masaomi and Yoshioka, Nobukazu and Ishikawa, Fuyuki},
  address = {New York, NY, USA},
  abstract = {Quantum application development typically involves verifying the construction procedures of quantum applications with a few qubits and running them on actual quantum computers based on the verified procedures. However, existing verification techniques face practical issues, such as the need for human intervention, long verification times, and insufficient descriptions. This study introduces a practical Design by Contract framework for quantum applications, designed for testing and debugging quantum applications on simulators. It allows for writing assertions about the input and output states of quantum circuits constructed by certain procedures and the post-processing of measurement results. The quantum application can be verified quickly by checking these assertions in test cases on simulators. Our framework introduces practical mechanisms for quantum application development. It separates the construction procedure of a quantum application and its assertions through parameter distinction, introduces an evaluation rule for early precondition checking, and reduces assertion-writing effort through assertion reuse mechanisms for inverting quantum circuits and using quantum circuits for qubits in a superposition state. We validated our framework through experiments and surveyed industry quantum computer researchers to assess its effectiveness.},
}",[Y],[Y], [International Conference on the Foundations of Software Engineering: Companion (FSE Companion)],[Conference],[Runtime assertion],"[Quantum algorithms and subroutines: Hadamard Test, Superdense Coding, Quantum Amplitude Amplification, Error Correction <One Qubit Error Correction for Bit Flip>, Quantum Fourier Transform, Quantum Phase Estimation]",[Un-specified],[Quantum algorithms and subroutines: 6],[Un-specified],[Un-specified],[Y],"[2,9,3,12,18,24,13,19]","[Total:5,7,66,6,1,38,56,71]",[Un-specified],[N],N/A,N/A,N/A,[Un-specified],[Un-specified],[Ideal simulator],[Measurement outcome],[Un-specified],[Un-specified],[Property: General property],[Un-specified],[Un-specified],[Overall execution time],[Y],[OSF: https://osf.io/k6ygp/overview]
43.0,Faster and Better Quantum Software Testing through Specification Reduction and Projective Measurements,"Oldfield, Noah H. and Laaber, Christoph and Yue, Tao and Ali, Shaukat",2025.0,10.1145/3714468,ACM Trans. Softw. Eng. Methodol.,https://doi.org/10.1145/3714468,Association for Computing Machinery,"Quantum computing (QC) promises polynomial and exponential speedups in many domains, such as unstructured search and prime number factoring. However, quantum programs yield probabilistic outputs from exponentially growing distributions and are vulnerable to quantum-specific faults. Existing quantum software testing (QST) approaches treat quantum superpositions as classical distributions. This leads to two major limitations when applied to quantum programs: (1) an exponentially growing sample space distribution and (2) failing to detect quantum-specific faults such as phase flips. To overcome these limitations, we introduce a QST approach, which applies a reduction algorithm to a quantum program specification. The reduced specification alleviates the limitations (1) by enabling faster sampling through quantum parallelism and (2) by performing projective measurements in the mixed Hadamard basis. Our evaluation of 143 quantum programs across four categories demonstrates significant improvements in test runtimes and fault detection with our reduction approach. Average test runtimes improved from 169.9 s to 11.8 s, with notable enhancements in programs with large circuit depths (383.1 s to 33.4 s) and large program specifications (464.8 s to 7.7 s). Furthermore, our approach increases mutation scores from  (54.5%)  to  (74.7%) , effectively detecting phase flip faults that non-reduced specifications miss. These results underline our approach's importance to improve QST efficiency and effectiveness.","@article{10.1145/3714468,
  year = {2025},
  volume = {34},
  url = {https://doi.org/10.1145/3714468},
  title = {Faster and Better Quantum Software Testing through Specification Reduction and Projective Measurements},
  publisher = {Association for Computing Machinery},
  numpages = {39},
  number = {7},
  month = {August},
  keywords = {Quantum computing, software testing, quantum program specification, projective measurements},
  journal = {ACM Trans. Softw. Eng. Methodol.},
  issue_date = {September 2025},
  issn = {1049-331X},
  doi = {10.1145/3714468},
  author = {Oldfield, Noah H. and Laaber, Christoph and Yue, Tao and Ali, Shaukat},
  articleno = {198},
  address = {New York, NY, USA},
  abstract = {Quantum computing (QC) promises polynomial and exponential speedups in many domains, such as unstructured search and prime number factoring. However, quantum programs yield probabilistic outputs from exponentially growing distributions and are vulnerable to quantum-specific faults. Existing quantum software testing (QST) approaches treat quantum superpositions as classical distributions. This leads to two major limitations when applied to quantum programs: (1) an exponentially growing sample space distribution and (2) failing to detect quantum-specific faults such as phase flips. To overcome these limitations, we introduce a QST approach, which applies a reduction algorithm to a quantum program specification. The reduced specification alleviates the limitations (1) by enabling faster sampling through quantum parallelism and (2) by performing projective measurements in the mixed Hadamard basis. Our evaluation of 143 quantum programs across four categories demonstrates significant improvements in test runtimes and fault detection with our reduction approach. Average test runtimes improved from 169.9 s to 11.8 s, with notable enhancements in programs with large circuit depths (383.1 s to 33.4 s) and large program specifications (464.8 s to 7.7 s). Furthermore, our approach increases mutation scores from  (54.5%)  to  (74.7%) , effectively detecting phase flip faults that non-reduced specifications miss. These results underline our approach's importance to improve QST efficiency and effectiveness.},
}",[Y],[Y],[ACM Transactions on Software Engineering and Methodology (TOSEM)],[Journal],[Software testing],"[Quantum algorithms and subroutines: Grover Search <Grover Search Oracle>, Graph State Preparation, Quantum Walk]","[Rieffel et al.: [@book{rieffel2011quantum,
  title={Quantum computing: A gentle introduction},
  author={Rieffel, Eleanor G and Polak, Wolfgang H},
  year={2011},
  publisher={MIT press}
}], Un-specified]",[Quantum algorithms and subroutines: 4],[Un-specified],[Mutants: 2145],[Y],"[From 6 to 9, From 3 to 16, From 3 to 5, From 2 to 8, 3, 2, 6, 5, 4, 7]",[Un-specified],"[From 2 to 684, From 5 to 18, From 1 to 154, From 3 to 70, 3, 6, 4, 8, 14, 11, 69, 11, 41, 17, 13]",[Y],"[Random search], [Greedy algorithm with the default program specification]","[Naivety],[Ablation]","[Mann-Whitney U test: $p$-value, Vargha and Delaney's $\hat{A}_{12}$ statistics, Magnitude], [Kruskal-Wallis test: $p$-value], [Spearman's rank correlation test: Spearman rank coefficient]",[Un-specified],[Un-specified],[Ideal simulator],[Measurement outcome],[Adaptive: 10 times the rank of program specification],"[100, 30]",[Specification: Quantum state],"[Wrong output oracle: None],[Output probability oracle:Pearson's chi-square test]","[Specification reduction rate], [Mutation score], [Reduction rate]","[Runtime speedup], [Runtime slowdown]; [Overall execution time]",[Y],[Zenodo: https://zenodo.org/records/11191215]
44.0,HornBro: Homotopy-Like Method for Automated Quantum Program Repair,"Tan, Siwei and Lu, Liqiang and Xiang, Debin and Chu, Tianyao and Lang, Congliang and Chen, Jintao and Hu, Xing and Yin, Jianwei",2025.0,10.1145/3715751,Proc. ACM Softw. Eng.,https://doi.org/10.1145/3715751,Association for Computing Machinery,"Quantum programs provide exponential speedups compared to classical programs in certain areas, but they also inevitably encounter logical faults. Automatically repairing quantum programs is much more challenging than repairing classical programs due to the non-replicability of data, the vast search space of program inputs, and the new programming paradigm. Existing works based on semantic-based or learning-based program repair techniques are fundamentally limited in repairing efficiency and effectiveness. In this work, we propose HornBro, an efficient framework for automated quantum program repair. The key insight of HornBro lies in the homotopy-like method, which iteratively switches between the classical and quantum parts. This approach allows the repair tasks to be efficiently offloaded to the most suitable platforms, enabling a progressive convergence toward the correct program. We start by designing an implication assertion pragma to enable rigorous specifications of quantum program behavior, which helps to generate a quantum test suite automatically. This suite leverages the orthonormal bases of quantum programs to accommodate different encoding schemes. Given a fixed number of test cases, it allows the maximum input coverage of potential counter-example candidates. Then, we develop a Clifford approximation method with an SMT-based search to transform the patch localization program into a symbolic reasoning problem. Finally, we offload the computationally intensive repair of gate parameters to quantum hardware by leveraging the differentiability of quantum gates. Experiments suggest that HornBro increases the repair success rate by more than 62.5% compared to the existing repair techniques, supporting more types of quantum bugs. It also achieves 35.7\texttimes{} speedup in the repair and 99.9% gate reduction of the patch.","@article{10.1145/3715751,
  year = {2025},
  volume = {2},
  url = {https://doi.org/10.1145/3715751},
  title = {HornBro: Homotopy-Like Method for Automated Quantum Program Repair},
  publisher = {Association for Computing Machinery},
  numpages = {23},
  number = {FSE},
  month = {June},
  keywords = {Automated Program Repair, Program Verification, Quantum Computing},
  journal = {Proc. ACM Softw. Eng.},
  issue_date = {July 2025},
  doi = {10.1145/3715751},
  author = {Tan, Siwei and Lu, Liqiang and Xiang, Debin and Chu, Tianyao and Lang, Congliang and Chen, Jintao and Hu, Xing and Yin, Jianwei},
  articleno = {FSE034},
  address = {New York, NY, USA},
  abstract = {Quantum programs provide exponential speedups compared to classical programs in certain areas, but they also inevitably encounter logical faults. Automatically repairing quantum programs is much more challenging than repairing classical programs due to the non-replicability of data, the vast search space of program inputs, and the new programming paradigm. Existing works based on semantic-based or learning-based program repair techniques are fundamentally limited in repairing efficiency and effectiveness. In this work, we propose HornBro, an efficient framework for automated quantum program repair. The key insight of HornBro lies in the homotopy-like method, which iteratively switches between the classical and quantum parts. This approach allows the repair tasks to be efficiently offloaded to the most suitable platforms, enabling a progressive convergence toward the correct program. We start by designing an implication assertion pragma to enable rigorous specifications of quantum program behavior, which helps to generate a quantum test suite automatically. This suite leverages the orthonormal bases of quantum programs to accommodate different encoding schemes. Given a fixed number of test cases, it allows the maximum input coverage of potential counter-example candidates. Then, we develop a Clifford approximation method with an SMT-based search to transform the patch localization program into a symbolic reasoning problem. Finally, we offload the computationally intensive repair of gate parameters to quantum hardware by leveraging the differentiability of quantum gates. Experiments suggest that HornBro increases the repair success rate by more than 62.5% compared to the existing repair techniques, supporting more types of quantum bugs. It also achieves 35.7\texttimes{} speedup in the repair and 99.9% gate reduction of the patch.},
}",[Y],[Y],[International Conference on the Foundations of Software Engineering (FSE)],[Conference],[Program repair],"[Quantum algorithms and subroutines: Quantum Fourier Transform, Quantum Walk, Deutsch-Jozsa Algorithm, Grover Search, Cat State Preparation <Greenberger-Horne-Zeilinger State Preparation>, Amplitude Estimation, Quantum Phase Estimation, Variational Quantum Eigensolver, Vehicle Routing, Quantum Approximation Optimization Algorithm, Quantum Neural Network], [Real-world benchmarks: Bugs4Q, Qbugs]","[Bugs4Q: [@inproceedings{zhao2021bugs4q,
  title={Bugs4Q: A benchmark of real bugs for quantum programs},
  author={Zhao, Pengzhan and Zhao, Jianjun and Miao, Zhongtao and Lan, Shuhan},
  booktitle={2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  pages={1373--1376},
  year={2021},
  organization={IEEE}
}], https://github.com/Z-928/Bugs4Q], [Qbugs: [@inproceedings{campos2021qbugs,
  title={Qbugs: A collection of reproducible bugs in quantum algorithms and a supporting infrastructure to enable controlled quantum software testing and debugging experiments},
  author={Campos, Jos{\'e} and Souto, Andr{\'e}},
  booktitle={2021 IEEE/ACM 2nd International Workshop on Quantum Software Engineering (Q-SE)},
  pages={28--32},
  year={2021},
  organization={IEEE}
}], Un-specified]","[Quantum algorithms and subroutines: 11], [Real-world benchmarks: 239]","[Mutation operators: Delete gate, Add gate, Replace gate]",[Mutants: 2200],[Y],[From 5 to 20],"[Total: From 23 to 241, From 459 to 19948, From 18 to 78, From 234 to 10530, From 11 to 41, From 37 to 307, From 26 to 258, From 29 to 470, From 25 to 323, From 31 to 121, From 90 to 1260]",[Un-specified],[Y],"[LLM-QAPR], [Syn-QFST], [Syn-QSD], [Basic-QAPR], [Quito], [QuSBT], [Random test suite generator], [Local search]","[SOTA], [Composite], [Composite], [Naivety], [Composite], [Composite], [Ablation], [Ablation]",[Un-specified],"[Classical inputs: Gate parameters related to a measurement basis set and a gate set], [Initial quantum states: Separable states prepared via state vectors from the orthonormal state space]","[From $3^{1}$ to $3^{17}$, From $12^{1}$ to $12^{17}$]","[Ideal simulator],[Physical hardware]",[Measurement outcome],[Un-specified],[Un-specified],[Specification: Probability distribution],[Output probability oracle: Specific assertions],"[Repair rate], [Distance between the repaired and correct programs in unitary matrices], [Approximation accuracy]","[Repair time], [Number of gates of the patches], [Test suite generation time], [Localization time], [Estimated execution time on the quantum computer]",[N],[Zenodo: https://zenodo.org/records/14288140]
45.0,Quantum Concolic Testing,"Xia, Shangzhou and Zhao, Jianjun and Zhang, Fuyuan and Guo, Xiaoyu",2025.0,10.1145/3728926,Proc. ACM Softw. Eng.,https://doi.org/10.1145/3728926,Association for Computing Machinery,"This paper presents the first concolic testing framework explicitly designed for quantum programs. The framework introduces quantum constraint generation methods for quantum control statements that quantify quantum states and offers a symbolization method for quantum variables. Based on this framework, we generate path constraints for each concrete execution path of a quantum program. These constraints guide the exploration of new paths, with a quantum constraint solver determining outcomes to create novel input samples, thereby enhancing branch coverage. Our framework has been implemented in Python and integrated with Qiskit for practical evaluation. Experimental results show that our concolic testing framework improves branch coverage, generates high-quality quantum input samples, and detects bugs, demonstrating its effectiveness and efficiency in quantum programming and bug detection. Regarding branch coverage, our framework achieves more than 74.27% on quantum programs with under 5 qubits.","@article{10.1145/3728926,
  year = {2025},
  volume = {2},
  url = {https://doi.org/10.1145/3728926},
  title = {Quantum Concolic Testing},
  publisher = {Association for Computing Machinery},
  numpages = {21},
  number = {ISSTA},
  month = {June},
  keywords = {Concolic Testing, Quantum Computing, Test Coverage},
  journal = {Proc. ACM Softw. Eng.},
  issue_date = {July 2025},
  doi = {10.1145/3728926},
  author = {Xia, Shangzhou and Zhao, Jianjun and Zhang, Fuyuan and Guo, Xiaoyu},
  articleno = {ISSTA051},
  address = {New York, NY, USA},
  abstract = {This paper presents the first concolic testing framework explicitly designed for quantum programs. The framework introduces quantum constraint generation methods for quantum control statements that quantify quantum states and offers a symbolization method for quantum variables. Based on this framework, we generate path constraints for each concrete execution path of a quantum program. These constraints guide the exploration of new paths, with a quantum constraint solver determining outcomes to create novel input samples, thereby enhancing branch coverage. Our framework has been implemented in Python and integrated with Qiskit for practical evaluation. Experimental results show that our concolic testing framework improves branch coverage, generates high-quality quantum input samples, and detects bugs, demonstrating its effectiveness and efficiency in quantum programming and bug detection. Regarding branch coverage, our framework achieves more than 74.27% on quantum programs with under 5 qubits.},
}",[Y],[Y],[International Symposium on Software Testing and Analysis (ISSTA)],[Conference],[Software testing],"[Quantum algorithms and subroutines: Un-specified], [Real-world benchmarks: Bugs4Q]",[Un-specified],"[Quantum algorithms and subroutines: Un-specified], [Real-world benchmarks: Un-specified]",[Real-world bugs: Bugs4Q],[Un-specified],[Y],"[1,2,3,4]","[Total: 5,10,20]",[Un-specified],[Y],"[Random state vector generator], [Random quantum circuit generator], [Quito], [QuraTest]","[Naivety], [Naivety], [SOTA], [SOTA] ",[Un-specified],"[Classical inputs: Un-specified], [Initial quantum states: State vectors generated by a quantum constraint solver]",[300],[Ideal simulator],[Measurement outcome],[Un-specified],[10],[Un-specified],[Output probability oracle: Quantum constraints],"[Program branch coverage], [Quality performance], [Probability of finding a bug type]",[Rate of improving branch coverage],[NN],N/A
46.0,Preparation and Utilization of Mixed States for Testing Quantum Programs,"Li, Yuechen and Cai, Kai-Yuan and Yin, Beibei",2025.0,10.1145/3736757,ACM Trans. Softw. Eng. Methodol.,https://doi.org/10.1145/3736757,Association for Computing Machinery,"Due to the growing demand for high-quality quantum programs (QPs), unit testing is employed to check the behavior of QPs. As for quantum inputs of testing, most studies limit test inputs to pure states, whereas mixed states representing probabilistic mixtures of pure states are almost excluded from the test process. Besides, when achieving the input domain coverage, lots of pure-state test cases (PSTCs) with pure states as inputs should be employed, leading to high time costs for testing. To handle that, this article explores using mixed states as test inputs for better utilization of quantum information. From the perspective of input domain coverage, applying mixed-state test cases (MSTCs) replacing PSTCs can simplify the test suite and accordingly promote test efficiency. Owing to the mixture of multiple pure states, a single MSTC is more likely to detect a fault than a PSTC, thereby enhancing test effectiveness. This article then proposes a unit testing framework, including generation and execution of MSTCs. Also, this article presents two guidelines and two parameterized quantum circuits to prepare desired mixed states. Empirical studies evaluate the performance of MSTCs and the experimental results demonstrate that MSCTs generally consume less time and detect more faults than PSTCs.","@article{10.1145/3736757,
  year = {2025},
  volume = {34},
  url = {https://doi.org/10.1145/3736757},
  title = {Preparation and Utilization of Mixed States for Testing Quantum Programs},
  publisher = {Association for Computing Machinery},
  numpages = {44},
  number = {8},
  month = {October},
  keywords = {Quantum software engineering, Software testing, Mixed states, S-ADA},
  journal = {ACM Trans. Softw. Eng. Methodol.},
  issue_date = {November 2025},
  issn = {1049-331X},
  doi = {10.1145/3736757},
  author = {Li, Yuechen and Cai, Kai-Yuan and Yin, Beibei},
  articleno = {238},
  address = {New York, NY, USA},
  abstract = {Due to the growing demand for high-quality quantum programs (QPs), unit testing is employed to check the behavior of QPs. As for quantum inputs of testing, most studies limit test inputs to pure states, whereas mixed states representing probabilistic mixtures of pure states are almost excluded from the test process. Besides, when achieving the input domain coverage, lots of pure-state test cases (PSTCs) with pure states as inputs should be employed, leading to high time costs for testing. To handle that, this article explores using mixed states as test inputs for better utilization of quantum information. From the perspective of input domain coverage, applying mixed-state test cases (MSTCs) replacing PSTCs can simplify the test suite and accordingly promote test efficiency. Owing to the mixture of multiple pure states, a single MSTC is more likely to detect a fault than a PSTC, thereby enhancing test effectiveness. This article then proposes a unit testing framework, including generation and execution of MSTCs. Also, this article presents two guidelines and two parameterized quantum circuits to prepare desired mixed states. Empirical studies evaluate the performance of MSTCs and the experimental results demonstrate that MSCTs generally consume less time and detect more faults than PSTCs.},
}",[Y],[Y],[ACM Transactions on Software Engineering and Methodology (TOSEM)],[Journal],[Software testing],"[Quantum algorithms and subroutines: Identity, Quantum Fourier Transform, Linear Pauli Rotation, Linear Amplitude Function, Integer Comparator, Quadratic Form, Weighted Adder]","[Qiskit circuit library: [Un-specified], https://github.com/Qiskit/qiskit/tree/stable/1.2/qiskit/circuit/library]",[Quantum algorithms and subroutines: 7],"[Mutation operators: Add gate, Replace gate, Switch qubit, Delete conditional, Delete branch, Delete gate, Modify mathematics, Modify loop]",[Versions: 36],[Y],"[From 1 to 6, From 2 to 7, From 2 to 12, From 4 to 8, From 2 to 14]","[Total: From 1 to 93, From 1 to 90, From 1 to 102, From 1 to 81, From 5 to 25, From 6 to 26, From 12 to 32, From 0 to 189, From 0 to 183, From 9 to 581, From 9 to 611, From 0 to 1180, From 0 to 1178, From 0 to 1192]","[From 1 to 43, From 1 to 42, From 1 to 39, From 5 to 25, From 4 to 19. From 6 to 26, From 12 to 32, From 0 to 112, From 0 to 106, From 6 to 317, From 6 to 321, From 0 to 801, From 0 to 812, From 0 to 800, From 0 to 807, From 0 to 812]",[Y],[Pure-state test cases],[SOTA],[Un-specified],"[Classical inputs: Numbers, Vectors, Matrices], [Initial quantum states: Mixed states]","[12,150,486,132,625,30]",[Ideal simulator],[Measurement outcome],[Fixed: 1024],[20],[Specification: Quantum state],[Output probability oracle: Mann-Whitney U test],[Number of detected faults],"[Overall execution time], [State preparation time]",[Y],[Zenodo: https://doi.org/10.5281/zenodo.15462299]
51.0,On Repairing Quantum Programs Using ChatGPT,"Guo, Xiaoyu and Zhao, Jianjun and Zhao, Pengzhan",2024.0,10.1145/3643667.3648223,2024 IEEE/ACM 5th International Workshop on Quantum Software Engineering (Q-SE),https://doi.org/10.1145/3643667.3648223,Association for Computing Machinery,"Automated Program Repair (APR) is a vital area in software engineering that generates automatic patches for vulnerable programs. While numerous techniques have been proposed for repairing classical programs, quantum programming lacks a comparable automated repair technique. In this initial exploration, we investigate the use of ChatGPT for quantum program repair and evaluate its performance on Bugs4Q, a benchmark suite of quantum program bugs. Our findings demonstrate the feasibility of employing ChatGPT for quantum program repair. Specifically, we assess ChatGPT’s ability to address bugs within the Bugs4Q benchmark, revealing its success in repairing 29 out of 38 bugs. This research represents a promising step towards automating the repair process for quantum programs.CCS CONCEPTS• Software and its engineering → Software testing and debugging.","@inproceedings{10649790,
  year = {2024},
  volume = {},
  title = {On Repairing Quantum Programs Using ChatGPT},
  pages = {9-16},
  number = {},
  month = {April},
  keywords = {Knowledge engineering,Software testing,Computer bugs,Training data,Maintenance engineering,Benchmark testing,Programming,Automatic Program Repair,Quantum Programming,Debugging},
  issn = {},
  doi = {},
  booktitle = {2024 IEEE/ACM 5th International Workshop on Quantum Software Engineering (Q-SE)},
  author = {Guo, Xiaoyu and Zhao, Jianjun and Zhao, Pengzhan},
  abstract = {Automated Program Repair (APR) is a vital area in software engineering that generates automatic patches for vulnerable programs. While numerous techniques have been proposed for repairing classical programs, quantum programming lacks a comparable automated repair technique. In this initial exploration, we investigate the use of ChatGPT for quantum program repair and evaluate its performance on Bugs4Q, a benchmark suite of quantum program bugs. Our findings demonstrate the feasibility of employing ChatGPT for quantum program repair. Specifically, we assess ChatGPT’s ability to address bugs within the Bugs4Q benchmark, revealing its success in repairing 29 out of 38 bugs. This research represents a promising step towards automating the repair process for quantum programs.CCS CONCEPTS• Software and its engineering → Software testing and debugging.},
}",[Y],[Y],[International Workshop on Quantum Software Engineering (Q-SE)],[Workshop],[Program repair],[Real-world benchmarks: Bugs4Q],[Un-specified],[Real-world benchmarks: 38],[Real-world bugs: Bugs4Q],[Un-specified],[N],[Un-specified],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],"[Repair rate], [Number of successful runs]",[Un-specified],[N],N/A
52.0,A Strategy of Dynamic Random Testing with Hybrid Distance Metrics for Quantum Programs,"Huang, Linzhi and Pei, Hanyu and Li, Yuechen and Yin, Beibei and Cai, Kai-Yuan",2024.0,10.1109/QRS62785.2024.00011,"2024 IEEE 24th International Conference on Software Quality, Reliability and Security (QRS)",https://ieeexplore.ieee.org/abstract/document/10684628,IEEE Press,"Quantum Computing (QC) leverages quantum mechanics to manipulate quantum information, holding greater potential than classical computing. To fully exploit QC’s potential, it is crucial to ensure the reliability and quality of quantum programs. Research on quantum program testing is still at its early stage, in which some distinctive features of quantum programs, e.g., superposition and entanglement, may be overlooked, and the fault detection capability and testing effectiveness are rather limited. Besides, the input space of quantum programs may exponentially grow when the number of qubits increases, posing great challenges to testing quantum programs. It is imperative to develop a proper testing strategy to effectively select the potential failure-causing test cases and detect faults faster. In this paper, test cases with both basis states and superposition ones are considered and generated to cover more input space. A hybrid distance measurement method based on quantum fidelity and Hamming distance is presented for measuring the similarity among quantum test cases. Furthermore, a Dynamic Random Testing strategy based on Hybrid distance metrics (DRT-H) for quantum programs is proposed, which combines the hybrid distance metrics and the feedback mechanism of the classical Dynamic Random Testing (DRT) strategy to aDeutsch-Jozsa Algorithm Algorithmust the testing profile and guide the test case selection. Experimental studies demonstrate that the proposed DRT-H strategy outperforms the baseline testing strategies in most cases.","@inproceedings{10684628,
  year = {2024},
  volume = {},
  title = {A Strategy of Dynamic Random Testing with Hybrid Distance Metrics for Quantum Programs},
  pages = {1-12},
  number = {},
  month = {July},
  keywords = {Quantum entanglement,Fault detection,Subspace constraints,Software algorithms,Software quality,Distance measurement,Software reliability,Dynamic random testing,quantum program testing,hybrid distance metrics,superposition,software cybernetics,S-ADA},
  issn = {2693-9177},
  doi = {10.1109/QRS62785.2024.00011},
  booktitle = {2024 IEEE 24th International Conference on Software Quality, Reliability and Security (QRS)},
  author = {Huang, Linzhi and Pei, Hanyu and Li, Yuechen and Yin, Beibei and Cai, Kai-Yuan},
  abstract = {Quantum Computing (QC) leverages quantum mechanics to manipulate quantum information, holding greater potential than classical computing. To fully exploit QC’s potential, it is crucial to ensure the reliability and quality of quantum programs. Research on quantum program testing is still at its early stage, in which some distinctive features of quantum programs, e.g., superposition and entanglement, may be overlooked, and the fault detection capability and testing effectiveness are rather limited. Besides, the input space of quantum programs may exponentially grow when the number of qubits increases, posing great challenges to testing quantum programs. It is imperative to develop a proper testing strategy to effectively select the potential failure-causing test cases and detect faults faster. In this paper, test cases with both basis states and superposition ones are considered and generated to cover more input space. A hybrid distance measurement method based on quantum fidelity and Hamming distance is presented for measuring the similarity among quantum test cases. Furthermore, a Dynamic Random Testing strategy based on Hybrid distance metrics (DRT-H) for quantum programs is proposed, which combines the hybrid distance metrics and the feedback mechanism of the classical Dynamic Random Testing (DRT) strategy to aDeutsch-Jozsa Algorithm Algorithmust the testing profile and guide the test case selection. Experimental studies demonstrate that the proposed DRT-H strategy outperforms the baseline testing strategies in most cases.},
}",[Y],[Y],"[International Conference on Software Quality, Reliability and Security (QRS)]",[Conference],[Software testing],"[Quantum algorithms and subroutines: Quantum Fourier Transform, Quantum Adder, Random Clifford, Quantum Phase Estimation]","[VeriQBench: [@article{chen2022VeriQBench,
  title={VeriQBench: A benchmark for multiple types of quantum circuits},
  author={Chen, Kean and Fang, Wang and Guan, Ji and Hong, Xin and Huang, Mingyu and Liu, Junyi and Wang, Qisheng and Ying, Mingsheng},
  journal={arXiv preprint arXiv:2206.10880},
  year={2022}
}], Un-specified]",[Quantum algorithms and subroutines: 4],"[Mutation operators: Delete gate, Modify qubit, Add gate, Switch qubit, Move gate, Modify rotation angles, Replace gate]",[Versions: 20],[N],"[7,8]","[Total: 36,8,52,108]",[Un-specified],[Y],"[Random testing], [Random partition testing], [Adaptive random testing], [Dynamic random testing], [Dynamic random testing with fidelity]","[Naivety], [Ablation], [Adaption], [Ablation], [Ablation]",[Mann-Whitney U test: $p$-value],"[Initial quantum states: Computational basis states, Separable states modelled by Bloch sphere]","[256, 512]",[Ideal simulator],[Measurement outcome],"[Fixed: 50], [Adaptive:  the number of possible outputs for a specific input multiplied by 100]",[50],[Un-specified],"[Wrong output oracle: Swap test],[Output probability oracle: Pearson's chi-square test]",[E-measure],[Overall execution time],[N],N/A
54.0,A Framework for Debugging Quantum Programs,"Rovara, Damian and Burgholzer, Lukas and Wille, Robert",2025.0,10.1109/QSW67625.2025.00024,2025 IEEE International Conference on Quantum Software (QSW),https://ieeexplore.ieee.org/abstract/document/11134329,IEEE Press,"Recent advancements in quantum computing software are gradually increasing the scope and size of quantum programs being developed. At the same time, however, these larger programs provide more possibilities for functional errors that are harder to detect and resolve. Meanwhile, debugging tools that could aid developers in resolving these errors are still barely existent and far from what we take for granted in classical design automation and software engineering. As a result, even if one manages to identify the incorrect behavior of a developed quantum program, detecting and resolving the underlying errors in the program remains a time-consuming and tedious task. Moreover, the exponential growth of the state space in quantum programs makes the efficient manual investigation of errors radically difficult even for respectively simple algorithms, and almost impossible as the number of qubits increases. To address this problem, this work proposes a debugging framework, available as an open-source implementation at https://github.com/cda-tum/mqt-debugger. It assists developers in debugging errors in quantum programs, allowing them to efficiently identify the existence of errors and diagnose their causes. Users are given the ability to place assertions in the code that test for the correctness of a given algorithm and are evaluated using classical simulations of the underlying quantum program. Once an assertion fails, the proposed framework employs different diagnostic methods to point towards possible error causes. This way, the debugging workload for quantum programs is drastically reduced.","@inproceedings{11134329,
  year = {2025},
  volume = {},
  title = {A Framework for Debugging Quantum Programs},
  pages = {130-136},
  number = {},
  month = {July},
  keywords = {Design automation,Codes,Qubit,Debugging,Manuals,Software,Software engineering,quantum computing,debugging,verification,static analysis,dynamic analysis},
  issn = {},
  doi = {10.1109/QSW67625.2025.00024},
  booktitle = {2025 IEEE International Conference on Quantum Software (QSW)},
  author = {Rovara, Damian and Burgholzer, Lukas and Wille, Robert},
  abstract = {Recent advancements in quantum computing software are gradually increasing the scope and size of quantum programs being developed. At the same time, however, these larger programs provide more possibilities for functional errors that are harder to detect and resolve. Meanwhile, debugging tools that could aid developers in resolving these errors are still barely existent and far from what we take for granted in classical design automation and software engineering. As a result, even if one manages to identify the incorrect behavior of a developed quantum program, detecting and resolving the underlying errors in the program remains a time-consuming and tedious task. Moreover, the exponential growth of the state space in quantum programs makes the efficient manual investigation of errors radically difficult even for respectively simple algorithms, and almost impossible as the number of qubits increases. To address this problem, this work proposes a debugging framework, available as an open-source implementation at https://github.com/cda-tum/mqt-debugger. It assists developers in debugging errors in quantum programs, allowing them to efficiently identify the existence of errors and diagnose their causes. Users are given the ability to place assertions in the code that test for the correctness of a given algorithm and are evaluated using classical simulations of the underlying quantum program. Once an assertion fails, the proposed framework employs different diagnostic methods to point towards possible error causes. This way, the debugging workload for quantum programs is drastically reduced.},
}",[Y],[Y],[International Conference on Quantum Software (QSW)],[Conference],[Runtime assertion],"[Quantum algorithms and subroutines: Deutsch-Jozsa Algorithm], [Artificial programs]","[MQT bench: [@article{quetschlich2023mqt,
  title={MQT Bench: Benchmarking software and design automation tools for quantum computing},
  author={Quetschlich, Nils and Burgholzer, Lukas and Wille, Robert},
  journal={Quantum},
  volume={7},
  pages={1062},
  year={2023},
  publisher={Verein zur F{\""o}rderung des Open Access Publizierens in den Quantenwissenschaften}}
], https://www.cda.cit.tum.de/mqtbench/]","[Quantum algorithms and subroutines:1], [Artificial programs:1]",[Un-specified],[Un-specified],[N],"[13, 130]",[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Un-specified],[100],[Ideal simulator],[State vector],N/A,[Un-specified],[Property: General property],[Un-specified],"[Success rate in identifying errors], [Reduction rate for the number of lines]",[Un-specified],[N],[GitHub: https://github.com/munich-quantum-toolkit/debugger]
55.0,A Tool For Debugging Quantum Circuits,"Metwalli, Sara Ayman and Van Meter, Rodney",2022.0,10.1109/QCE53715.2022.00085,2022 IEEE International Conference on Quantum Computing and Engineering (QCE),https://ieeexplore.ieee.org/abstract/document/9951172,IEEE Press,"As the scale of quantum programs grows to match that of classical software, the nascent field of quantum software engineering must mature and tools such as debuggers will become increasingly important. However, developing a quantum debugger is challenging due to the nature of a quantum computer, sneaking a peek at the value of a quantum state will cause either partial or complete collapse of the superposition and may destroy the necessary entanglement. As a first step to developing a full quantum circuit debugger, we have designed and implemented a quantum circuit debugging tool. The tool allows the user to divide the circuit vertically or horizontally into smaller chunks known as slices, and manage their simulation or execution for either interactive debugging or automated testing. The tool also enables developers to track gates within the overall circuit and each chunk to understand their behavior better. Feedback on usefulness and usability from early users shows that using the tool to slice and test their circuits has helped make the debugging process more time-efficient for them.","@inproceedings{9951172,
  year = {2022},
  volume = {},
  title = {A Tool For Debugging Quantum Circuits},
  pages = {624-634},
  number = {},
  month = {Sep.},
  keywords = {Quantum entanglement,Debugging,Quantum state,Logic gates,Software,Quantum circuit,Usability,Quantum circuits,Debugging,Quantum Software},
  issn = {},
  doi = {10.1109/QCE53715.2022.00085},
  booktitle = {2022 IEEE International Conference on Quantum Computing and Engineering (QCE)},
  author = {Metwalli, Sara Ayman and Van Meter, Rodney},
  abstract = {As the scale of quantum programs grows to match that of classical software, the nascent field of quantum software engineering must mature and tools such as debuggers will become increasingly important. However, developing a quantum debugger is challenging due to the nature of a quantum computer, sneaking a peek at the value of a quantum state will cause either partial or complete collapse of the superposition and may destroy the necessary entanglement. As a first step to developing a full quantum circuit debugger, we have designed and implemented a quantum circuit debugging tool. The tool allows the user to divide the circuit vertically or horizontally into smaller chunks known as slices, and manage their simulation or execution for either interactive debugging or automated testing. The tool also enables developers to track gates within the overall circuit and each chunk to understand their behavior better. Feedback on usefulness and usability from early users shows that using the tool to slice and test their circuits has helped make the debugging process more time-efficient for them.},
}",[Y],[Y],[International Conference on Quantum Computing and Engineering (QCE)],[Conference],[Runtime assertion],"[Quantum algorithms and subroutines: Quantum Fourier Transform, Quantum Adder, Simon's Algorithm, Grover Search, Quantum Counting]",[Un-specified],[Quantum algorithms and subroutines: 5],[None],[None],[N],"[3,4,6,13,8]","[Total: 7,11,172,470]",[Un-specified],[N],N/A,N/A,N/A,[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[N],N/A
59.0,Assessing the Effectiveness of Input and Output Coverage Criteria for Testing Quantum Programs,"Ali, Shaukat and Arcaini, Paolo and Wang, Xinyi and Yue, Tao",2021.0,10.1109/ICST49551.2021.00014,"2021 14TH IEEE CONFERENCE ON SOFTWARE TESTING, VERIFICATION AND VALIDATION (ICST 2021)",https://ieeexplore.ieee.org/abstract/document/9438603,IEEE Press,"Quantum programs implement Quantum algorithms and subroutines solving complex computational problems. Testing such programs is challenging due to the inherent characteristics of Quantum Computing (QC), such as the probabilistic nature and computations in superposition. However, automated and systematic testing is needed to ensure the correct behavior of quantum programs. To this end, we present an approach called Quito (QUantum InpuT Output coverage) consisting of three coverage criteria defined on the inputs and outputs of a quantum program, together with their test generation strategies. Moreover, we define two types of test oracles, together with a procedure to determine the passing and failing of test suites with statistical analyses. To evaluate the cost-effectiveness of the three coverage criteria, we conducted experiments with five quantum programs. We used mutation analysis to determine the coverage criteria’ effectiveness and cost in terms of the number of test cases. Based on the results of mutation analysis, we also identified equivalent mutants for quantum programs.","@inproceedings{WOS:000680831800002,
  year = {2021},
  volume = {},
  title = {Assessing the Effectiveness of Input and Output Coverage Criteria for Testing Quantum Programs},
  pages = {13-23},
  number = {},
  month = {April},
  keywords = {Software testing,Systematics,Quantum algorithm,Statistical analysis,Conferences,Probabilistic logic,Test pattern generators,quantum programs,software testing,coverage criteria,mutation analysis},
  issn = {2159-4848},
  doi = {10.1109/ICST49551.2021.00014},
  booktitle = {2021 14TH IEEE CONFERENCE ON SOFTWARE TESTING, VERIFICATION AND VALIDATION (ICST 2021)},
  author = {Ali, Shaukat and Arcaini, Paolo and Wang, Xinyi and Yue, Tao},
  abstract = {Quantum programs implement Quantum algorithms and subroutines solving complex computational problems. Testing such programs is challenging due to the inherent characteristics of Quantum Computing (QC), such as the probabilistic nature and computations in superposition. However, automated and systematic testing is needed to ensure the correct behavior of quantum programs. To this end, we present an approach called Quito (QUantum InpuT Output coverage) consisting of three coverage criteria defined on the inputs and outputs of a quantum program, together with their test generation strategies. Moreover, we define two types of test oracles, together with a procedure to determine the passing and failing of test suites with statistical analyses. To evaluate the cost-effectiveness of the three coverage criteria, we conducted experiments with five quantum programs. We used mutation analysis to determine the coverage criteria’ effectiveness and cost in terms of the number of test cases. Based on the results of mutation analysis, we also identified equivalent mutants for quantum programs.},
}",[Y],[Y],"[International Conference on Software Testing, Verification, and Validation (ICST)]",[Conference],[Software testing],"[Quantum algorithms and subroutines: Entangled Qubits, Swap Test, Remote-controlled Randomness, Increment Qubits, Decrement Qubits]","[O'reilly: [@book{johnston2019programming,
  title={Programming quantum computers: essential algorithms and code samples},
  author={Johnston, Eric R and Harrigan, Nic and Gimeno-Segovia, Mercedes},
  year={2019},
  publisher={O'Reilly Media}
}], https://oreilly-qc.github.io/]",[Quantum algorithms and subroutines:5],"[Mutation operators: Add gate, Delete gate, Replace gate, Modify mathematics]",[Mutants: 78],[N],"[2,3]",[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Initial quantum states: Computational basis states],"[2,4,8]",[Ideal simulator],[Measurement outcome],[Fixed: 2000],[Un-specified],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle: Wilcoxon signed rank test]",[Mutation score],[Average size of test suites killing the mutants],[Y],[Personal Website: https://simula-complex.github.io/Quantum-Software-Engineering/ICST21.html]
60.0,Application of Combinatorial Testing to Quantum Programs,"Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat",2021.0,10.1109/QRS54544.2021.00029,"2021 IEEE 21ST INTERNATIONAL CONFERENCE ON SOFTWARE QUALITY, RELIABILITY AND SECURITY (QRS 2021)",https://ieeexplore.ieee.org/abstract/document/9724888,IEEE Press,"The capability of Quantum Computing (QC) in solving complex problems has been increasingly recognized. However, similar to classical computing, to fully exploit QC's potential, it is important to ensure the correctness of quantum programs. Doing so via software testing is, however, very challenging because of QC's inherent properties: superposition and entanglement. Towards the direction of ensuring the correctness of quantum programs, we propose an approach called QuCAT (QUantum CombinAtorial Testing) for systematic and automated testing of quantum programs by benefiting from combinatorial testing, which has been proven to be cost-effective in testing classical programs. QuCAT supports two combinatorial test suite generation scenarios, i.e., generating combinatorial test suites of a given strength, and incrementally generating and executing combinatorial test suites of increasing strength until a fault is found. The approach employs two types of test oracles to assess test results. We performed an empirical study with 18 faulty versions of quantum programs to evaluate QuCAT with strengths of two, three, and four in the two test generation scenarios. We compare the cost-effectiveness of combinatorial testing of various strengths and random testing (taken as baseline approach). Results show that combinatorial testing always performs better than random testing with the same cost and finds faults more quickly (in terms of required number of test cases). In addition, in most cases, combinatorial testing with a higher strength outperforms the lower strength in terms of effectiveness.","@inproceedings{WOS:000814747000019,
  year = {2021},
  volume = {},
  title = {Application of Combinatorial Testing to Quantum Programs},
  pages = {179-188},
  number = {},
  month = {Dec},
  keywords = {Quantum computing,Systematics,Costs,Combinatorial testing,Conferences,Software quality,Software reliability,quantum programs,quantum software testing,combinatorial testing},
  issn = {2693-9177},
  doi = {10.1109/QRS54544.2021.00029},
  booktitle = {2021 IEEE 21ST INTERNATIONAL CONFERENCE ON SOFTWARE QUALITY, RELIABILITY AND SECURITY (QRS 2021)},
  author = {Wang, Xinyi and Arcaini, Paolo and Yue, Tao and Ali, Shaukat},
  abstract = {The capability of Quantum Computing (QC) in solving complex problems has been increasingly recognized. However, similar to classical computing, to fully exploit QC's potential, it is important to ensure the correctness of quantum programs. Doing so via software testing is, however, very challenging because of QC's inherent properties: superposition and entanglement. Towards the direction of ensuring the correctness of quantum programs, we propose an approach called QuCAT (QUantum CombinAtorial Testing) for systematic and automated testing of quantum programs by benefiting from combinatorial testing, which has been proven to be cost-effective in testing classical programs. QuCAT supports two combinatorial test suite generation scenarios, i.e., generating combinatorial test suites of a given strength, and incrementally generating and executing combinatorial test suites of increasing strength until a fault is found. The approach employs two types of test oracles to assess test results. We performed an empirical study with 18 faulty versions of quantum programs to evaluate QuCAT with strengths of two, three, and four in the two test generation scenarios. We compare the cost-effectiveness of combinatorial testing of various strengths and random testing (taken as baseline approach). Results show that combinatorial testing always performs better than random testing with the same cost and finds faults more quickly (in terms of required number of test cases). In addition, in most cases, combinatorial testing with a higher strength outperforms the lower strength in terms of effectiveness.},
}",[Y],[Y],"[International Conference on Software Quality, Reliability and Security (QRS)]",[Conference],[Software testing],"[Quantum algorithms and subroutines: Quantum Fourier Transform <Inverse Quantum Fourier Transform>, Quantum Random Access Memory,Bernstein-Vazirani Algorithm, Simon's Algorithm, Quantum Conditional Execution, Add Squared Algorithm]",[Un-specified],[Quantum algorithms and subroutines: 6],[Mutation operators: Un-specified],[Versions: 18],[N],"[6,7,11,10,9,5]","[Total:25,21,60,15,40]","[22,3,26,56,12,5]",[Y],[Random testing],[Naivety],"[Mann-Whitney U test: $p$-value, Vargha and Delaney's $\hat{A}_{12}$ statistics, Magnitude], [Fisher's exact test: $p$-value, Odds ratio]",[Initial quantum states: Computational basis states],[500],[Ideal simulator],[Measurement outcome],[Un-specified],[500],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle:Pearson's chi-square test]","[Number of times a test suite found a fault out of total runs], [Percentage of faults identified]",[Size of the generated test suite],[Y],[GitHub: https://github.com/Simula-COMPLEX/qucat-paper]
67.0,Understanding the Impact of Quantum Noise on Quantum Programs,"Pan, Zhonghao and Feng, Yang and Li, Zhiyuan and Liu, Yunxin and Li, Yuanchun",2023.0,10.1109/SANER56733.2023.00047,"2023 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)",https://ieeexplore.ieee.org/abstract/document/10123493,IEEE Press,"Quantum computing is expected to introduce the next era of computing speed and power, and its software - quantum program is gaining increasing research interest in the software engineering community. A significant characteristic of quantum computing is the existence of noise. Unlike classical computers where the output of a program is usually deterministic, the execution of a quantum program may be affected by quantum noise. Such a difference may cause difficulties or misunderstandings for developers shifting from classical programming to quantum programming. To understand the impact of quantum noise on quantum programs and its implications for software developers, we conduct a series of studies with real-world quantum programs and quantum computing environments. Specifically, we first measure and analyze the noise in a real quantum computer by testing it with a basic quantum program. We find that a non-neglectable amount of quantum noise generally exists in real quantum computers. Then we investigate the robustness of quantum programs against different quantum noises by testing 18 real -world quantum programs and 50,000 randomly generated quantum circuits in simulated and real environments. We observe that quantum noise can significantly influence the correctness of quantum programs, and different quantum circuit structures show diverse sensitivity patterns under the same noise. Based on the observations, we build a machine learning model to predict the fidelity of a quantum program under certain quantum noise. The model achieves a small average fidelity prediction error, meaning the impact of noise can be precisely estimated statistically.","@inproceedings{WOS:001008282200037,
  year = {2023},
  volume = {},
  title = {Understanding the Impact of Quantum Noise on Quantum Programs},
  pages = {426-437},
  number = {},
  month = {March},
  keywords = {Computers,Quantum computing,Machine learning,Programming,Predictive models,Software,Robustness,quantum computing,quantum noise,quantum software engineering,robustness,empirical study},
  issn = {2640-7574},
  doi = {10.1109/SANER56733.2023.00047},
  booktitle = {2023 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  author = {Pan, Zhonghao and Feng, Yang and Li, Zhiyuan and Liu, Yunxin and Li, Yuanchun},
  abstract = {Quantum computing is expected to introduce the next era of computing speed and power, and its software - quantum program is gaining increasing research interest in the software engineering community. A significant characteristic of quantum computing is the existence of noise. Unlike classical computers where the output of a program is usually deterministic, the execution of a quantum program may be affected by quantum noise. Such a difference may cause difficulties or misunderstandings for developers shifting from classical programming to quantum programming. To understand the impact of quantum noise on quantum programs and its implications for software developers, we conduct a series of studies with real-world quantum programs and quantum computing environments. Specifically, we first measure and analyze the noise in a real quantum computer by testing it with a basic quantum program. We find that a non-neglectable amount of quantum noise generally exists in real quantum computers. Then we investigate the robustness of quantum programs against different quantum noises by testing 18 real -world quantum programs and 50,000 randomly generated quantum circuits in simulated and real environments. We observe that quantum noise can significantly influence the correctness of quantum programs, and different quantum circuit structures show diverse sensitivity patterns under the same noise. Based on the observations, we build a machine learning model to predict the fidelity of a quantum program under certain quantum noise. The model achieves a small average fidelity prediction error, meaning the impact of noise can be precisely estimated statistically.},
}",[Y],[Y],"[International Conference on Software Analysis, Evolution and Reengineering (SANER)]",[Conference],[Software testing],"[Quantum algorithms and subroutines: Hidden Shift Algorithm, Quantum Fourier Transform, Quantum Adder, Bernstein-Vazirani Algorithm, Quantum Teleportation, Deutsch-Jozsa Algorithm, Grover Search, Superdense Coding], [Quantum applications: Quantum Key Distribution Protocol], [Artificial programs]",[Un-specified],"[Quantum algorithms and subroutines: Un-specified], [Artificial programs: 50000]",[None],[None],[Y],"[2, From 3 to 12, From 3 to 8]","[Total: 6,10,12,4,7,8,11,From 5 to 96], [Specific: [Muti-qubit gates: 0,1,2]]","[5,7,7,7,2,6,5,9,From 3 to 14]",[Y],[Noise prediction model based on linear regression],[Naivety],[Un-specified],[Initial quantum states: Computational basis states],[Un-specified],"[Physical hardware],[Noisy simulator]",[Measurement outcome],"[Fixed: 12000, 1000]",[1000],[Un-specified],[Un-specified],"[Quantum state fidelity], [Accuracy]",[Un-specified],[Y],[GitHub: https://github.com/WindFrank/QuantumDataAndProgram]
70.0,"Equivalence, identity, and unitarity checking in black-box testing of quantum programs","Long, Peixun and Zhao, Jianjun",2024.0,10.1016/j.jss.2024.112000,JOURNAL OF SYSTEMS AND SOFTWARE,https://www.sciencedirect.com/science/article/pii/S0164121224000438,Elsevier,"Quantum programs exhibit inherent non -deterministic behavior, which poses more significant challenges for error discovery compared to classical programs. While several testing methods have been proposed for quantum programs, they often overlook fundamental questions in black -box testing. In this paper, we bridge this gap by presenting three novel algorithms specifically designed to address the challenges of equivalence, identity, and unitarity checking in black -box testing of quantum programs. We also explore optimization techniques for these algorithms, including specialized versions for equivalence and unitarity checking, and provide valuable insights into parameter selection to maximize performance and effectiveness. To evaluate the effectiveness of our proposed methods, we conducted comprehensive experimental evaluations, which demonstrate that our methods can rigorously perform equivalence, identity, and unitarity checking, offering robust support for black -box testing of quantum programs.","@article{WOS:001188339000001,
  year = {2024},
  volume = {211},
  title = {Equivalence, identity, and unitarity checking in black-box testing of quantum programs},
  journal = {JOURNAL OF SYSTEMS AND SOFTWARE},
  doi = {10.1016/j.jss.2024.112000},
  author = {Long, Peixun and Zhao, Jianjun},
  abstract = {Quantum programs exhibit inherent non -deterministic behavior, which poses more significant challenges for error discovery compared to classical programs. While several testing methods have been proposed for quantum programs, they often overlook fundamental questions in black -box testing. In this paper, we bridge this gap by presenting three novel algorithms specifically designed to address the challenges of equivalence, identity, and unitarity checking in black -box testing of quantum programs. We also explore optimization techniques for these algorithms, including specialized versions for equivalence and unitarity checking, and provide valuable insights into parameter selection to maximize performance and effectiveness. To evaluate the effectiveness of our proposed methods, we conducted comprehensive experimental evaluations, which demonstrate that our methods can rigorously perform equivalence, identity, and unitarity checking, offering robust support for black -box testing of quantum programs.},
}",[Y],[Y],[Journal of Systems and Software (JSS)],[Journal],[Software testing],"[Quantum algorithms and subroutines: Quantum Fourier Transform <Raw and Inverse Quantum Fourier Transform>,Quantum Phase Estimation <Raw and Inverse Quantum Phase Estimation>, Quantum Teleportation, Harrow-Hassidim-Lloyd Algorithm <Subroutine>], [Artificial programs]","[Quanto: [@article{pointing2024optimizing,
  title={Quanto: Optimizing quantum circuits with automatic generation of circuit identities},
  author={Pointing, Jessica and Padon, Oded and Jia, Zhihao and Ma, Henry and Hirth, Auguste and Palsberg, Jens and Aiken, Alex},
  journal={Quantum Science and Technology},
  volume={9},
  number={4},
  pages={045009},
  year={2024},
  publisher={IOP Publishing}
}], Un-specified], [Juan Carlos et al.: [@article{garcia2011equivalent,
  title={Equivalent quantum circuits},
  author={Garcia-Escartin, Juan Carlos and Chamorro-Posada, Pedro},
  journal={arXiv preprint arXiv:1110.2998},
  year={2011}
}], Un-specified]","[Quantum algorithms and subroutines: 6], [Artificial programs: 6]","[Mutation operators: Add gate, Delete gate, Replace gate, Add measurement, Delete measurement]",[Versions: 63],[N],"[2,3,5,6]","[Total: 6,1,17,34,0,44,60,1,6,1,0,17,680,17,4,4,12,22,680]",[Un-specified],[Y],[Original algorithms],[Ablation],[Un-specified],[Initial quantum states: Pauli eigenstates],"[1,2,3,4,6,10,15,20,30,50]",[Ideal simulator],[Measurement outcome],"[Adaptive: Proportional to an estimated lower bound], [Varied: Proportions configured as 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.7, 0.9, 1.0]",[100],[Property: General property],"[Property-based oracle: Swap test, Trace-related distance]",[Number of passing tests],[Overall execution time],[Y],[GitHub: https://github.com/MgcosA/EvaluationCodeOfQuantumRelationChecking/]
71.0,Testing Multi-Subroutine Quantum Programs: From Unit Testing to Integration Testing,"Long, Peixun and Zhao, Jianjun",2024.0,10.1145/3656339,ACM TRANSACTIONS ON SOFTWARE ENGINEERING AND METHODOLOGY,https://doi.org/10.1145/3656339,Association for Computing Machinery,"Quantum computing has emerged as a promising field with the potential to revolutionize various domains by harnessing the principles of quantum mechanics. As quantum hardware and algorithms continue to advance, developing high-quality quantum software has become crucial. However, testing quantum programs poses unique challenges due to the distinctive characteristics of quantum systems and the complexity of multi-subroutine programs. This article addresses the specific testing requirements of multi-subroutine quantum programs. We begin by investigating critical properties by surveying existing quantum libraries and providing insights into the challenges of testing these programs. Building upon this understanding, we focus on testing criteria and techniques based on the whole testing process perspective, spanning from unit testing to integration testing. We delve into various aspects, including IO analysis, quantum relation checking, structural testing, behavior testing, integration of subroutine pairs, and test case generation. We also introduce novel testing principles and criteria to guide the testing process. We conduct comprehensive testing on typical quantum subroutines, including diverse mutants and randomized inputs, to evaluate our proposed approach. The analysis of failures provides valuable insights into the effectiveness of our testing methodology. Additionally, we present case studies on representative multi-subroutine quantum programs, demonstrating the practical application and effectiveness of our proposed testing principles and criteria.","@article{WOS:001283366800008,
  year = {2024},
  volume = {33},
  url = {https://doi.org/10.1145/3656339},
  title = {Testing Multi-Subroutine Quantum Programs: From Unit Testing to Integration Testing},
  publisher = {Association for Computing Machinery},
  numpages = {61},
  number = {6},
  month = {June},
  keywords = {Quantum computing, software testing, unit testing, integration testing},
  journal = {ACM TRANSACTIONS ON SOFTWARE ENGINEERING AND METHODOLOGY},
  issue_date = {July 2024},
  issn = {1049-331X},
  doi = {10.1145/3656339},
  author = {Long, Peixun and Zhao, Jianjun},
  articleno = {147},
  address = {New York, NY, USA},
  abstract = {Quantum computing has emerged as a promising field with the potential to revolutionize various domains by harnessing the principles of quantum mechanics. As quantum hardware and algorithms continue to advance, developing high-quality quantum software has become crucial. However, testing quantum programs poses unique challenges due to the distinctive characteristics of quantum systems and the complexity of multi-subroutine programs. This article addresses the specific testing requirements of multi-subroutine quantum programs. We begin by investigating critical properties by surveying existing quantum libraries and providing insights into the challenges of testing these programs. Building upon this understanding, we focus on testing criteria and techniques based on the whole testing process perspective, spanning from unit testing to integration testing. We delve into various aspects, including IO analysis, quantum relation checking, structural testing, behavior testing, integration of subroutine pairs, and test case generation. We also introduce novel testing principles and criteria to guide the testing process. We conduct comprehensive testing on typical quantum subroutines, including diverse mutants and randomized inputs, to evaluate our proposed approach. The analysis of failures provides valuable insights into the effectiveness of our testing methodology. Additionally, we present case studies on representative multi-subroutine quantum programs, demonstrating the practical application and effectiveness of our proposed testing principles and criteria.},
}",[Y],[Y],[ACM Transactions on Software Engineering and Methodology (TOSEM)],[Journal],[Software testing],"[Quantum algorithms and subroutines: Identity, Reverse Qubits, Swap Qubits, Controlled Rotation, Quantum Fourier Transform, Quantum Teleportation]",[Un-specified],[Quantum algorithms and subroutines: 6],"[Mutation operators: Add gate, Delete gate, Replace gate, Add calling statement, Remove calling statement, Modify calling statements, Modify control-flow statements, Modify classical expressions, Modify classical variables, Add measurement, Delete measurement]","[Mutants: 14,32,11,38,31,66]",[Y],"[2,3,10,1,8,9,1,12,1,2,6]",[Un-specified],[Un-specified],[N],N/A,N/A,N/A,"[Classical inputs: Numbers], [Initial quantum states: Computational basis states, Superposition states, Mixed states]","[200,100,1000,100,800,900,100,600,100,200,600]",[Ideal simulator],[Measurement outcome],[Un-specified],[Un-specified],"[Specification: Quantum state],[Specification: Probability distribution],[Property: General property]","[Wrong output oracle: None, Extra unitary operations], [Property-based oracle: Un-specified]",[Kill rate],[Un-specified],[N],N/A
73.0,Mitigating Noise in Quantum Software Testing Using Machine Learning,"Muqeet, Asmar and Yue, Tao and Ali, Shaukat and Arcaini, Paolo",2024.0,10.1109/TSE.2024.3462974,IEEE Transactions on Software Engineering,https://ieeexplore.ieee.org/abstract/document/10682972,IEEE Press,"Quantum Computing (QC) promises computational speedup over classic computing. However, noise exists in near-term quantum computers. Quantum software testing (for gaining confidence in quantum software's correctness) is inevitably impacted by noise, i.e., it is impossible to know if a test case failed due to noise or real faults. Existing testing techniques test quantum programs without considering noise, i.e., by executing tests on ideal quantum computer simulators. Consequently, they are not directly applicable to test quantum software on real quantum computers or noisy simulators. Thus, we propose a noise-aware approach (named $\mathit{QOIN}$QOIN) to alleviate the noise effect on test results of quantum programs. $\mathit{QOIN}$QOIN employs machine learning techniques (e.g., transfer learning) to learn the noise effect of a quantum computer and filter it from a program's outputs. Such filtered outputs are then used as the input to perform test case assessments (determining the passing or failing of a test case execution against a test oracle). We evaluated $\mathit{QOIN}$QOIN on IBM's 23 noise models, Google's two available noise models, and Rigetti's Quantum Virtual Machine, with six real-world and 800 artificial programs. We also generated faulty versions of these programs to check if a failing test case execution can be determined under noise. Results show that $\mathit{QOIN}$QOIN can reduce the noise effect by more than $80\%$80% on most noise models. We used an existing test oracle to evaluate $\mathit{QOIN}$QOIN's effectiveness in quantum software testing. The results showed that $\mathit{QOIN}$QOIN attained scores of $99\%$99%, $75\%$75%, and $86\%$86% for precision, recall, and F1-score, respectively, for the test oracle across six real-world programs. For artificial programs, $\mathit{QOIN}$QOIN achieved scores of $93\%$93%, $79\%$79%, and $86\%$86% for precision, recall, and F1-score respectively. This highlights $\mathit{QOIN}$QOIN's effectiveness in learning noise patterns for noise-aware quantum software testing.","@article{WOS:001369099900018,
  year = {2024},
  volume = {50},
  title = {Mitigating Noise in Quantum Software Testing Using Machine Learning},
  pages = {2947-2961},
  number = {11},
  month = {Nov},
  keywords = {Noise,Quantum computing,Qubit,Computers,Software testing,Logic gates,Computational modeling,Software testing and debugging,computing methodologies,quantum computing,and machine learning},
  journal = {IEEE Transactions on Software Engineering},
  issn = {1939-3520},
  doi = {10.1109/TSE.2024.3462974},
  author = {Muqeet, Asmar and Yue, Tao and Ali, Shaukat and Arcaini, Paolo},
  abstract = {Quantum Computing (QC) promises computational speedup over classic computing. However, noise exists in near-term quantum computers. Quantum software testing (for gaining confidence in quantum software's correctness) is inevitably impacted by noise, i.e., it is impossible to know if a test case failed due to noise or real faults. Existing testing techniques test quantum programs without considering noise, i.e., by executing tests on ideal quantum computer simulators. Consequently, they are not directly applicable to test quantum software on real quantum computers or noisy simulators. Thus, we propose a noise-aware approach (named $\mathit{QOIN}$QOIN) to alleviate the noise effect on test results of quantum programs. $\mathit{QOIN}$QOIN employs machine learning techniques (e.g., transfer learning) to learn the noise effect of a quantum computer and filter it from a program's outputs. Such filtered outputs are then used as the input to perform test case assessments (determining the passing or failing of a test case execution against a test oracle). We evaluated $\mathit{QOIN}$QOIN on IBM's 23 noise models, Google's two available noise models, and Rigetti's Quantum Virtual Machine, with six real-world and 800 artificial programs. We also generated faulty versions of these programs to check if a failing test case execution can be determined under noise. Results show that $\mathit{QOIN}$QOIN can reduce the noise effect by more than $80\%$80% on most noise models. We used an existing test oracle to evaluate $\mathit{QOIN}$QOIN's effectiveness in quantum software testing. The results showed that $\mathit{QOIN}$QOIN attained scores of $99\%$99%, $75\%$75%, and $86\%$86% for precision, recall, and F1-score, respectively, for the test oracle across six real-world programs. For artificial programs, $\mathit{QOIN}$QOIN achieved scores of $93\%$93%, $79\%$79%, and $86\%$86% for precision, recall, and F1-score respectively. This highlights $\mathit{QOIN}$QOIN's effectiveness in learning noise patterns for noise-aware quantum software testing.},
}",[Y],[Y],[IEEE Transactions on Software Engineering (TSE)],[Journal],[Software testing],"[Quantum algorithms and subroutines: Cat State Preparation <Greenberger-Horne-Zeilinger State Preparation>, Simon's Algorithm, Quantum Fourier Transform, Quantum Adder <Addition>, Binary Similarity, Quantum Phase Estimation, Qubit Permutations <Permutations>, Expression Evaluation, N-Qubit Controlled NOT Program <N-CNOT>], [Artificial programs]","[Quantum algorithm zoo: [Un-specified], https://quantumalgorithmzoo.org/], [Quantum code repository: [Un-specified], https://quantumcomputinguk.org/code-repository]","[Quantum algorithms and subroutines: 9], [Artificial programs: 1000]",[Mutation operators: Modify gate],"[27], [3000]",[N],"[3, 4, 5, 6, 7]","[Total: 11,6,5,6,6,3,15,4,3]","[17,14,7,9,9,12,21,10,7]",[Y],[Algorithms executed on noisy backends without filtering],[Ablation],"[Mann-Whitney U test: $p$-value, Vargha and Delaney's $\hat{A}_{12}$ statistics]",[Un-specified],[Un-specified],"[Ideal simulator], [Noisy simulator]",[Measurement outcome],[Un-specified],[Un-specified],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle:Pearson's chi-square test]","[Hellinger Distance], [Changes in number of failed test cases], [F1 score], [Precision], [Recall]",[Un-specified],[N],N/A
74.0,Mutation Testing of Quantum Programs: A Case Study With Qiskit,"Fortunato, Daniel and CAMPOS, JOSÉ and ABREU, RUI",2022.0,10.1109/TQE.2022.3195061,IEEE Transactions on Quantum Engineering,https://ieeexplore.ieee.org/abstract/document/9844849,IEEE Press,"As quantum computing is still in its infancy, there is an inherent lack of knowledge and technology to test a quantum program properly. In the classical realm, mutation testing has been successfully used to evaluate how well a program's test suite detects seeded faults (i.e., mutants). In this article, building on the definition of syntactically equivalent quantum operations, we propose a novel set of mutation operators to generate mutants based on qubit measurements and quantum gates. To ease the adoption of quantum mutation testing, we further propose QMutPy, an extension of the well-known and fully automated open-source mutation tool MutPy. To evaluate QMutPy's performance, we conducted a case study on 24 real quantum programs written in IBM's Qiskit library. Furthermore, we show how better test suite coverage and improvements to test assertions can increase the test suites' mutation score and quality. QMutPy has proven to be an effective quantum mutation tool, providing insight into the current state of quantum tests and how to improve them.","@article{WOS:001369115500008,
  year = {2022},
  volume = {3},
  title = {Mutation Testing of Quantum Programs: A Case Study With Qiskit},
  pages = {1-17},
  number = {},
  month = {},
  keywords = {Software testing,Computers,Quantum computing,Codes,Qubit,Buildings,Logic gates,Quantum computing,quantum mutation testing,quantum software engineering,quantum software testing},
  journal = {IEEE Transactions on Quantum Engineering},
  issn = {2689-1808},
  doi = {10.1109/TQE.2022.3195061},
  author = {Fortunato, Daniel and CAMPOS, JOSÉ and ABREU, RUI},
  abstract = {As quantum computing is still in its infancy, there is an inherent lack of knowledge and technology to test a quantum program properly. In the classical realm, mutation testing has been successfully used to evaluate how well a program's test suite detects seeded faults (i.e., mutants). In this article, building on the definition of syntactically equivalent quantum operations, we propose a novel set of mutation operators to generate mutants based on qubit measurements and quantum gates. To ease the adoption of quantum mutation testing, we further propose QMutPy, an extension of the well-known and fully automated open-source mutation tool MutPy. To evaluate QMutPy's performance, we conducted a case study on 24 real quantum programs written in IBM's Qiskit library. Furthermore, we show how better test suite coverage and improvements to test assertions can increase the test suites' mutation score and quality. QMutPy has proven to be an effective quantum mutation tool, providing insight into the current state of quantum tests and how to improve them.},
}",[Y],[Y],[IEEE Transactions on Quantum Engineering (TQE)],[Journal],[Software testing],"[Quantum algorithms and subroutines: Variational Quantum Eigensolver <adapt_vqe, vqe>, Bernstein-Vazirani Algorithm, Born-Oppenheimer Potential Energy Surface Sampler <bopes_sampler>, Deutsch-Jozsa Algorithm, Quantum Evolution of Hamiltonian Algorithm <eoh>, Grover Search <grover, grover_optimizer>, Harrow-Hassidim-Lloyd Algorithm, Quantum Phase Estimation <Inverse: iqpe, qpe>, Quantum Approximate Optimization Algorithm, Quantum Generative Adversarial Network, Quantum Support Vector Machine, Shor's Algorithm, Simon's Algorithm, Variational Quantum Classfier]","[Qiskit aqua library: [Un-specified], https://github.com/qiskit-community/qiskit-aqua#migration-guide]",[Quantum algorithms and subroutines: 17],"[Mutation operators: Replace gate, Delete gate, Add gate, Add measurement, Delete measurement]","[Mutants: 146.96,63.27]",[N],[Un-specified],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Un-specified],[36.88],[Ideal simulator],[Measurement outcome],[Un-specified],[Un-specified],[Property: General property],"[Property-based oracle: Kruskal–Wallis nonparametric
test,Cohen’s d effect size]",[Mutation score],[Overall execution time],[Y],[GitHub: https://github.com/danielfobooss/mutpy]
78.0,Quantum circuit mutants: Empirical analysis and recommendations,"Usandizaga, Enaut Mendiluze and Ali, Shaukat and Yue, Tao and Arcaini, Paolo",2025.0,10.1007/s10664-025-10643-z,EMPIRICAL SOFTWARE ENGINEERING,https://link.springer.com/article/10.1007/s10664-025-10643-z,Springer,"As a new research area, quantum software testing lacks systematic testing benchmarks to assess testing techniques' effectiveness. Recently, some open-source benchmarks and mutation analysis tools have emerged. However, there is insufficient evidence on how various quantum circuit characteristics (e.g., circuit depth, number of quantum gates), algorithms (e.g., Quantum Approximate Optimization Algorithm), and mutation characteristics (e.g., mutation operators) affect the detection of mutants in quantum circuits. Studying such relations is important to systematically design faulty benchmarks with varied attributes (e.g., the difficulty in detecting a seeded fault) to facilitate assessing the cost-effectiveness of quantum software testing techniques efficiently. To this end, we present a large-scale empirical evaluation with more than 700K faulty benchmarks (quantum circuits) generated by mutating 382 real-world quantum circuits. Based on the results, we provide valuable insights for researchers to define systematic quantum mutation analysis techniques. We also provide a tool to recommend mutants to users based on chosen characteristics (e.g., a quantum algorithm type) and the required difficulty of detecting mutants. Finally, we also provide faulty benchmarks that can already be used to assess the cost-effectiveness of quantum software testing techniques.","@article{WOS:001469295100001,
  year = {2025},
  volume = {30},
  title = {Quantum circuit mutants: Empirical analysis and recommendations},
  number = {3},
  journal = {EMPIRICAL SOFTWARE ENGINEERING},
  doi = {10.1007/s10664-025-10643-z},
  author = {Usandizaga, Enaut Mendiluze and Ali, Shaukat and Yue, Tao and Arcaini, Paolo},
  abstract = {As a new research area, quantum software testing lacks systematic testing benchmarks to assess testing techniques' effectiveness. Recently, some open-source benchmarks and mutation analysis tools have emerged. However, there is insufficient evidence on how various quantum circuit characteristics (e.g., circuit depth, number of quantum gates), algorithms (e.g., Quantum Approximate Optimization Algorithm), and mutation characteristics (e.g., mutation operators) affect the detection of mutants in quantum circuits. Studying such relations is important to systematically design faulty benchmarks with varied attributes (e.g., the difficulty in detecting a seeded fault) to facilitate assessing the cost-effectiveness of quantum software testing techniques efficiently. To this end, we present a large-scale empirical evaluation with more than 700K faulty benchmarks (quantum circuits) generated by mutating 382 real-world quantum circuits. Based on the results, we provide valuable insights for researchers to define systematic quantum mutation analysis techniques. We also provide a tool to recommend mutants to users based on chosen characteristics (e.g., a quantum algorithm type) and the required difficulty of detecting mutants. Finally, we also provide faulty benchmarks that can already be used to assess the cost-effectiveness of quantum software testing techniques.},
}",[Y],[Y],[Empirical Software Engineering (EMSE)],[Journal],[Software testing],"[Quantum algorithms and subroutines: Amplitude Estimation, Deutsch-Jozsa Algorithm, Cat State Preparation <Greenberger-Horne-Zeilinger State Preparation>, Graph State Preparation, Ground State Calculation <groundstatelarge, groundstatemedium, groundstatesmall>, Grover Search <Grover Search without Ancilla: grover-noancilla, Grover Search with Ancilla: groverv-chain>, Quantum Approximate Optimization Algorithm <Portfolio Optimization with QAOA: portfolioqaoa, qaoa>, Variational Quantum Eigensolver <Porfolio Optimization with VQE: portfoliovqe, vqe>, Pricing Call Option, Pricing Put Option, Quantum Fourier Transform <qft, Quantun Fourier Transform Entangled: qftentangled>, Quantum Generative Adversarial Network, Quantum Phase Estimation <Quantum Phase Estimation Exact: qpeexact, Quantum Phase Estimation Inexact: qpeinexact>, Quantum Walk <QuantumWalk without Ancilla: qwalk-noancilla, Quantum Walk with Ancilla: qwalk-v-chain>, Real Amplitudes ansatz with Random Parameters, Routing Algorithm, Efficient SU2 ansatz with Random Parameters, Travelling Salesman, Two Local ansatz with random parameters, W-State Preparation]","[MQT bench: [@article{quetschlich2023mqt,
  title={MQT Bench: Benchmarking software and design automation tools for quantum computing},
  author={Quetschlich, Nils and Burgholzer, Lukas and Wille, Robert},
  journal={Quantum},
  volume={7},
  pages={1062},
  year={2023},
  publisher={Verein zur F{\""o}rderung des Open Access Publizierens in den Quantenwissenschaften}}
], https://www.cda.cit.tum.de/mqtbench/]",[Quantum algorithms and subroutines: 28],"[Mutation operators: Add gate, Delete gate, Replace gate]","[Mutants: 723,079]",[Y],[From 2 to 30],[Total: From 3 to 477],[From 2 to 402],[N],N/A,N/A,N/A,[Un-specified],[Un-specified],[Ideal simulator],[Measurement outcome],"[Fixed: 100,000]",[Un-specified],"[Specification: Dominate output],[Specification: Probability distribution]","[Wrong output oracle: None],[Output probability oracle: Pearson’s correlation coefficient]",[Mutation score],[Un-specified],[Y],[GitHub: https://github.com/EnautMendi/Quantum-Circuit-Mutants-Empirical-Evaluation]
81.0,SQUAD: software testing for quantum distributed learning software,"Park, Soohyun and Cho, Jae Hyun and Yook, Hyun Jun and Jhun, Ga San and Lee, Youn Kyu and Kim, Joongheon",2025.0,10.1007/s11227-025-07556-5,JOURNAL OF SUPERCOMPUTING,https://link.springer.com/article/10.1007/s11227-025-07556-5#citeas,Springer,"In modern neural network research, quantum neural network (QNN) methodologies have been widely adopted due to their inherent quantum advantages. Quantum learning-based models can be partitioned, with each segment distributed across multiple computing machines to preserve privacy-an approach referred to as quantum split learning. Although several novel QNN software testing techniques have been introduced, no methodology currently exists for testing quantum distributed learning software such as quantum split learning. To address this issue, this paper proposes a new software testing method for quantum distributed/split learning, named SQUAD. The proposed SQUAD automatically generates dummy code to complete Quantum learning-based models across separate machines and subsequently performs software testing on all machines. Additionally, a graphical user interface (GUI) for SQUAD is implemented to demonstrate its novelty and feasibility.","@article{WOS:001513703100004,
  year = {2025},
  volume = {81},
  title = {SQUAD: software testing for quantum distributed learning software},
  number = {9},
  journal = {JOURNAL OF SUPERCOMPUTING},
  doi = {10.1007/s11227-025-07556-5},
  author = {Park, Soohyun and Cho, Jae Hyun and Yook, Hyun Jun and Jhun, Ga San and Lee, Youn Kyu and Kim, Joongheon},
  abstract = {In modern neural network research, quantum neural network (QNN) methodologies have been widely adopted due to their inherent quantum advantages. Quantum learning-based models can be partitioned, with each segment distributed across multiple computing machines to preserve privacy-an approach referred to as quantum split learning. Although several novel QNN software testing techniques have been introduced, no methodology currently exists for testing quantum distributed learning software such as quantum split learning. To address this issue, this paper proposes a new software testing method for quantum distributed/split learning, named SQUAD. The proposed SQUAD automatically generates dummy code to complete Quantum learning-based models across separate machines and subsequently performs software testing on all machines. Additionally, a graphical user interface (GUI) for SQUAD is implemented to demonstrate its novelty and feasibility.},
}",[Y],[Y],[Journal of Supercomputing],[Journal],[Software testing],[Quantum learning-based models: Quantum Distributed Learning Software],[Un-specified],[Quantum learning-based models: 1],[Un-specified],[Un-specified],[N],[6],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Classical inputs: Images],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Specification: True label],[Un-specified],[Accuracy],[Un-specified],[N],N/A
83.0,Automatic repair of quantum programs via unitary operation,"Li, Yuechen and Pei, Hanyu and Huang, Linzhi and Yin, Beibei and Cai, Kai-Yuan",2024.0,10.1145/3664604,ACM Transactions on Software Engineering and Methodology,https://doi.org/10.1145/3664604,Association for Computing Machinery,"With the continuous advancement of quantum computing (QC), the demand for high-quality quantum programs (QPs) is growing. To avoid program failure, in software engineering, the technology of automatic program repair (APR) employs appropriate patches to remove potential bugs without the intervention of a human. However, the method tailored for repairing defective QPs is still absent. This article proposes, to the best of our knowledge, a new APR method named UnitAR that can repair QPs via unitary operation automatically. Based on the characteristics of superposition and entanglement in QC, the article constructs an algebraic model and adopts a generate-and-validate approach for the repair procedure. Furthermore, the article presents two schemes that can respectively promote the efficiency of generating patches and guarantee the effectiveness of applying patches. For the purpose of evaluating the proposed method, the article selects 29 mutated versions as well as five real-world buggy programs as the objects and introduces two traditional APR approaches GenProg and TBar as baselines. According to the experiments, UnitAR can fix 23 buggy programs, and this method demonstrates the highest efficiency and effectiveness among three APR approaches. Besides, the experimental results further manifest the crucial roles of two constituents involved in the framework of UnitAR.","@article{li2024automatic,
  title={Automatic repair of quantum programs via unitary operation},
  author={Li, Yuechen and Pei, Hanyu and Huang, Linzhi and Yin, Beibei and Cai, Kai-Yuan},
  journal={ACM Transactions on Software Engineering and Methodology},
  volume={33},
  number={6},
  pages={1--43},
  year={2024},
  publisher={ACM New York, NY}
}",[Y],[Y],[ACM Transactions on Software Engineering and Methodology (TOSEM)],[Journal],[Program repair],"[Quantum algorithms and subroutines: Root of NOT, Custom Conditional-phase, Remote-controlled Randomness, Entangled Qubits, Quantum Fourier Transform], [Real-world benchmarks: Bugs4Q]","[Bugs4Q: [@inproceedings{zhao2021bugs4q,
  title={Bugs4Q: A benchmark of real bugs for quantum programs},
  author={Zhao, Pengzhan and Zhao, Jianjun and Miao, Zhongtao and Lan, Shuhan},
  booktitle={2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  pages={1373--1376},
  year={2021},
  organization={IEEE}
}], https://github.com/Z-928/Bugs4Q], [Qbugs: [@inproceedings{campos2021qbugs,
  title={Qbugs: A collection of reproducible bugs in quantum algorithms and a supporting infrastructure to enable controlled quantum software testing and debugging experiments},
  author={Campos, Jos{\'e} and Souto, Andr{\'e}},
  booktitle={2021 IEEE/ACM 2nd International Workshop on Quantum Software Engineering (Q-SE)},
  pages={28--32},
  year={2021},
  organization={IEEE}
}], Un-specified]","[Quantum algorithms and subroutines: 5], [Real-world benchmarks: 5]","[Mutation operators: Add gate, Delete gate, Replace gate, Switch qubit], [Real-world bugs: Bugs4Q]",[Versions: 34],[Y],"[1,2,3,4,6,7,10]",[Un-specified],"[9,7,10,6,8,5,4,3,11]",[Y],"[GenProg], [TBar]","[Adaption], [Adaption]",[Un-specified],[Initial quantum states: Computational basis states],"[2, 4, 8, 16, 64, 128, 1024]",[Ideal simulator],[Measurement outcome],[Fixed: 1024],[50],"[Specification: Quantum state],[Specification: Quantum operator]",[Output probability oracle: Jensen-Shannon divergence],"[Repair rate], [Number of equivalent operators], [Error of similarity], [Error of unitarity]",[Overall execution time],[N],N/A
84.0,Bug-locating Method based on Statistical Testing for Quantum Programs.,"Sato, Naoto and Katsube, Ryota",2025.0,10.1109/TSE.2025.3597316,IEEE Transactions on Software Engineering,https://ieeexplore.ieee.org/abstract/document/11121593,IEEE Press,"When a bug is detected by testing a quantum program on a quantum computer, we want to determine its location to fix it. To locate the bug, the quantum program is divided into several segments, and each segment is tested. However, to prepare a quantum state that is input to a segment, it is necessary to execute all the segments ahead of that segment in a quantum computer. This means that the cost of testing each segment depends on its location. We can also locate a buggy segment only if it is confirmed that there are no bugs in all segments ahead of that buggy segment. Since a quantum program is tested statistically on the basis of measurement results, there is a tradeoff between testing accuracy and cost. These characteristics are unique to quantum programs and complicate locating bugs. We propose an efficient bug-locating method consisting of four approaches, i.e., cost-based binary search, early determination, finalization, and looking back, which take these characteristics into account. We present experimental results indicating that the proposed method can reduce bug-locating cost, represented as the number of executed quantum gates, compared with naive methods that do not use the four approaches. The limitations and usefulness of the proposed method are also discussed on the basis of the experimental results.","@article{sato2025bug,
  title={Bug-locating Method based on Statistical Testing for Quantum Programs},
  author={Sato, Naoto and Katsube, Ryota},
  journal={IEEE Transactions on Software Engineering},
  year={2025},
  publisher={IEEE}
}",[Y],[Y],[IEEE Transactions on Software Engineering (TSE)],[Journal],[Fault localization],"[Artificial programs], [Real-world benchmarks: QASMBench, Bugs4Q], [Quantum algorithms and subroutines: Quantum adder, Transform the Single-particle Basis of a Linearly Connected Electronic Structure, Implement Trotter Steps for Molecule LiH at Equilibrium Geometry, Bell State Preparation, Cat State Preparation, Deutsch-Jozsa Algorithm, Quantum Neural Network <dnn_n8, dnn_n2>, Error Correction <including Shor’s error correction algorithm for teleportation>, Fredkin Gate, Grover Search, Hidden Subgroup Problem, Harrow-Hassidim-Lloyd Algorithm, Quantum Fourier Transform <inverseqft_n4, qft_n4>, Ising Model Simulation, Entangled Swapping Gate, Linear Equation Solver, Learning Parity with Noise, Quantum Approximate Optimization Algorithm <qaoa_n3, qaoa_n6>, Quantum Repetition Code Encoder, Quantum Phase Estimation, Quantum Random Number Generator, Quantum Walk, Boolean Satisfiability Problem via Quantum Computing, Shor's Algorithm, Simon's Algorithm, Quantum Teleportation, Toffoli Gate, Variational Quantum Eigensolver, Bernstein-Vazirani Algorithm, Counterfeit Coin Finding Problem via Quantum Computing, Quantum Multiplier, Quantum Random Access Memory, Swap Test]","[Bugs4Q: [@inproceedings{zhao2021bugs4q,
  title={Bugs4Q: A benchmark of real bugs for quantum programs},
  author={Zhao, Pengzhan and Zhao, Jianjun and Miao, Zhongtao and Lan, Shuhan},
  booktitle={2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  pages={1373--1376},
  year={2021},
  organization={IEEE}
}], https://github.com/Z-928/Bugs4Q], [Qbugs: [@inproceedings{campos2021qbugs,
  title={Qbugs: A collection of reproducible bugs in quantum algorithms and a supporting infrastructure to enable controlled quantum software testing and debugging experiments},
  author={Campos, Jos{\'e} and Souto, Andr{\'e}},
  booktitle={2021 IEEE/ACM 2nd International Workshop on Quantum Software Engineering (Q-SE)},
  pages={28--32},
  year={2021},
  organization={IEEE}
}], Un-specified], [QASMBench: , [@article{li2023qasmbench,
  title={Qasmbench: A low-level quantum benchmark suite for nisq evaluation and simulation},
  author={Li, Ang and Stein, Samuel and Krishnamoorthy, Sriram and Ang, James},
  journal={ACM Transactions on Quantum Computing},
  volume={4},
  number={2},
  pages={1--26},
  year={2023},
  publisher={ACM New York, NY}
}],https://github.com/pnnl/QASMBench]","[Artificial programs: 1000], [Real-world benchmarks: 8], [Quantum algorithms and subroutines:53]",[Mutation operators: Replace gate],[Mutants: 10],[Y],"[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,22,23,25,30]","[Total: 50, 150, 250, 500, From 4 to 186798, From 2 to 84, 12630]",[Un-specified],[Y],"[Naive linear search], [Naive binary search]","[Naivety], [Naivety]",[Un-specified],[Initial quantum states: Computational basis states],[Un-specified],"[Ideal simulator], [Noisy simulator]",[Measurement outcome],[Adaptive: constant increase according to statistical results],[Un-specified],[Specification: Probability distribution],[Output probability oracle: chi-squared test],[Probability of successfully locating a bug],[Time to execute gates and measurement on quantum computers],[N],N/A
86.0,Poster: Fuzz testing of quantum program,"Wang, Jiyuan and Ma, Fucheng and Jiang, Yu",2021.0,10.1109/ICST49551.2021.00061,"2021 14th IEEE Conference on Software Testing, Verification and Validation (ICST)",https://ieeexplore.ieee.org/abstract/document/9438606,IEEE Press,"Nowadays, quantum program is widely used and quickly developed. However, the absence of testing methodology restricts their quality. Different input format and operator from traditional program make this issue hard to resolve. In this paper, we present QuanFuzz, a search-based test input generator for quantum program. We define the quantum sensitive information to evaluate test input for quantum program and use matrix generator to generate test cases with higher coverage. Because of the impossibility of copying qubit, we record the operations which lead initial seeds to test inputs instead of recording qubits themselves. First, we extract quantum sensitive information – measurement operations on those quantum registers and the sensitive branches associated with those measurement results, from the quantum source code. Then, we use the sensitive information guided algorithm to mutate the initial input matrix and select those matrices which improve the probability weight for a value of the quantum register to trigger the sensitive branch. QuanFuzz on benchmarks and acquired 20% - 60% more coverage compared to traditional testing methods.","@inproceedings{wang2021poster,
  title={Poster: Fuzz testing of quantum program},
  author={Wang, Jiyuan and Ma, Fucheng and Jiang, Yu},
  booktitle={2021 14th IEEE Conference on Software Testing, Verification and Validation (ICST)},
  pages={466--469},
  year={2021},
  organization={IEEE}
}",[Y],[Y],"[International Conference on Software Testing, Verification, and Validation (ICST)]",[Conference],[Software testing],[Un-specified],[Un-specified],[Un-specified: 7],[Un-specified],[Un-specified],[Y],"[2,3,4,5,6,7,8]",[Un-specified],[Un-specified],[Y],[Tradifuzz],[Adaption],[Un-specified],[Initial quantum states: Separable states prepared by basic gates],[Un-specified],[Ideal simulator],[Measurement outcome],[Un-specified],[5],[Un-specified],[Un-specified],[Probability to trigger the quantum sensitive branch],"[Overall execution time], [Number of iterations]",[N],N/A
94.0,From Ideal to Noisy: Adapting Property-Based Testing for Real-World Noisy Quantum Computers,"Pontolillo, Gabriel and Muqeet, Asmar and Ali, Shaukat and Mousavi, Mohammadreza",2025.0,,IEEE International Conference on Quantum Computing and Engineering (QCE),https://kclpure.kcl.ac.uk/ws/portalfiles/portal/342412270/Noise_aware_property_based_testing-8.pdf,,"Quantum software testing is essential for the quality
assurance of quantum programs. However, existing techniques
face many challenges, such as constructing test oracles and
distinguishing genuine faults from noise-induced errors. Propertybased testing is a promising solution for dealing with the test oracle
issue, which verifies general properties rather than requiring
inputs and outputs. However, its effectiveness in noisy quantum
environments has not been studied. To this end, we evaluate the
feasibility of applying property-based testing in noisy quantum
computers by integrating it with a state-of-the-art machine
learning-based noise mitigation method called QOIN.
Our results show that on average, QOIN mitigates noise for
individual circuits, though it may introduce outliers. Crucially,
this does not guarantee property preservation: We show that
some properties align better with QOIN, while others remain
closer under unmitigated noise. To address this, we apply a hybrid
approach that selectively applies QOIN during property-based
testing. We show that this hybrid approach improves alignment
with the ideal execution and significantly reduces false positives in
assertion outcomes across most executed mutants. This provides
a solid foundation for applying property-based testing to noisy
quantum systems.
","@inproceedings{pontolillo2025ideal,
  title={From Ideal to Noisy: Adapting Property-Based Testing for Real-World Noisy Quantum Computers},
  author={Pontolillo, Gabriel and Muqeet, Asmar and Ali, Shaukat and Mousavi, Mohammadreza},
  booktitle={IEEE International Conference on Quantum Computing and Engineering (QCE)},
  year={2025},
  organization={IEEE}
}",[Y],[Y],[International Conference on Quantum Computing and Engineering (QCE)],[Conference],[Software testing],"[Quantum algorithms and subroutines: Quantum Fourier Transform, Quantum Phase Estimation, Quantum Teleportation, Deutsch-Jozsa Algorithm, Grover Search]",[Un-specified],[Quantum algorithms and subroutines:5],"[Mutation toolings: QMutPy], [Mutation operators: Add gates]",[Mutants: 15],[Y],"[3,From 2 to 5, From 3 to 5, From 2 to 5, From 2 to 5, From 2 to 4]",[Un-specified],"[From 4 to 8, From 4 to 42, From 9 to 55, From 3 to 18, From 3 to 21]",[Y],[Original algorithms],[Ablation],[Un-specified],[Initial quantum states: Un-specified],[200],[Noisy simulator],[Measurement outcome],[Fixed: 3000],[Un-specified],[Property: General property],[Property-based oracle: None],"[Hellinger distance], [Number of failed assertions]",[Un-specified],[Y],[Figshare: https://figshare.com/articles/software/QuCheck_with_QOIN/28772231]
103.0,QuanFuzz: Fuzz testing of quantum program,"Wang, Jiyuan and Gao, Ming and Jiang, Yu and Lou, Jianguang and Gao, Yue and Zhang, Dongmei and Sun, Jiaguang",2018.0,,ArXiv,https://arxiv.org/abs/1810.10310,ArXiv,"Nowadays, quantum program is widely used and quickly developed. However, the absence of testing methodology restricts their quality. Different input format and operator from traditional program make this issue hard to resolve.
In this paper, we present QuanFuzz, a search-based test input generator for quantum program. We define the quantum sensitive information to evaluate test input for quantum program and use matrix generator to generate test cases with higher coverage. First, we extract quantum sensitive information -- measurement operations on those quantum registers and the sensitive branches associated with those measurement results, from the quantum source code. Then, we use the sensitive information guided algorithm to mutate the initial input matrix and select those matrices which improve the probability weight for a value of the quantum register to trigger the sensitive branch. The process keeps iterating until the sensitive branch triggered. We tested QuanFuzz on benchmarks and acquired 20% - 60% more coverage compared to traditional testing input generation.","@article{wang2018quanfuzz,
  title={QuanFuzz: Fuzz testing of quantum program},
  author={Wang, Jiyuan and Gao, Ming and Jiang, Yu and Lou, Jianguang and Gao, Yue and Zhang, Dongmei and Sun, Jiaguang},
  journal={arXiv preprint arXiv:1810.10310},
  year={2018}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],[Un-specified],[Un-specified],[Un-specified: 7],[Un-specified],[Un-specified],[Y],"[2,3,4,5,6,7,8]",[Un-specified],[Un-specified],[Y],[Random state vector generator <Random input generator>],[Naivety],[Un-specified],[Initial quantum states: Separable states prepared by basic gates],[Un-specified],[Ideal simulator],[Measurement outcome],[Un-specified],[5],[Un-specified],[Un-specified],[Probability to trigger the quantum sensitive branch],"[Overall execution time], [Number of iterations]",[N],N/A
105.0,NovaQ: Improving Quantum Program Testing through Diversity-Guided Test Case Generation,"Jin, Tiancheng and Xia, Shangzhou and Zhao, Jianjun",2025.0,,ArXiv,https://arxiv.org/abs/2509.04763,ArXiv,"Quantum programs are designed to run on quantum computers, leveraging quantum circuits to solve problems that are intractable for classical machines. As quantum computing advances, ensuring the reliability of quantum programs has become increasingly important. This paper introduces NovaQ, a diversity-guided testing framework for quantum programs. NovaQ combines a distribution-based test case generator with a novelty-driven evaluation module. The generator produces diverse quantum state inputs by mutating circuit parameters, while the evaluator quantifies behavioral novelty based on internal circuit state metrics, including magnitude, phase, and entanglement. By selecting inputs that map to infrequently covered regions in the metric space, NovaQ effectively explores under-tested program behaviors. We evaluate NovaQ on quantum programs of varying sizes and complexities. Experimental results show that NovaQ consistently achieves higher test input diversity and detects more bugs than existing baseline approaches.","@article{jin2025novaq,
  title={NovaQ: Improving Quantum Program Testing through Diversity-Guided Test Case Generation},
  author={Jin, Tiancheng and Xia, Shangzhou and Zhao, Jianjun},
  journal={arXiv preprint arXiv:2509.04763},
  year={2025}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],"[Quantum algorithms and subroutines: Grover Search, Quantum Phase Estimation, Quantum Fourier Transform]",[Un-specified],[Un-specified: 3],[Mutation operators: Replace gate],[Un-specified],[Y],"[From 3 to 12,5,5]",[Un-specified],[Un-specified],[Y],[QuraTest],[SOTA],[Un-specified],[Initial quantum states: IQFT generator],[1500],[Ideal simulator],[Measurement outcome],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Accuracy of finding bugs],[Un-specified],[N],N/A
106.0,A Black-box Testing Framework for Oracle Quantum Programs,"Peixun Long, Jianjun Zhao",2025.0,,ArXiv,https://arxiv.org/abs/2505.07243,ArXiv,"Oracle quantum programs are a fundamental class of quantum programs that serve as a critical bridge between quantum computing and classical computing. Many important Quantum algorithms and subroutines are built upon oracle quantum programs, making it essential to ensure their correctness during development. While software testing is a well-established approach for improving program reliability, no systematic method has been developed to test oracle quantum programs. This paper proposes a black-box testing framework designed for general oracle quantum programs. We define these programs formally, establish the foundational theory for their testing, and propose a detailed testing framework. We develop a prototype tool and conduct extensive experimental evaluations to evaluate the framework's effectiveness. Our results demonstrate that the proposed framework significantly aids developers in testing oracle quantum programs, providing insights to enhance the reliability of quantum software.","@article{long2025black,
  title={A Black-box Testing Framework for Oracle Quantum Programs},
  author={Long, Peixun and Zhao, Jianjun},
  journal={arXiv preprint arXiv:2505.07243},
  year={2025}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],"[Quantum algorithms and subroutines: Boolean Parity Function <Parity_P, Parity_Q>, Boolean IS2POWER Function, Boolean LESSTHAN Function, Quantum Adder, Hamilton Evolution <Position Operator: Hamilton X>, Ising Model Simulation <Ising Model: Ising>, Oracle Program Combined by Quantum Adder and Hamilton Evolution]",[Un-specified],[Quantum algorithms and subroutines: 10],[Mutation operators: Add gate],"[Mutants: 16, 16, 16, 8, 8, 8, 8]",[N],[Un-specified],[Un-specified],[Un-specified],[N],[Original algorithms],[Ablation],[Un-specified],[Initial quantum states: selected from quantum equivalence classes],[Number of equivalence classes times 100],[Ideal simulator],[Measurement outcome],"[Varied: From 1 to 10], [Varied: 1,2,5,10,20,50,100,200,500,1000]",[Un-specified],[Property: General property],[Dominant output oracle],"[number of PASS inputs, number of PASS shots]",[Average running time],[Y],[GitHub: https://github.com/MgcosA/Code_of_Testing_Oracle_Quantum_Program_Article]
107.0,A coverage-guided testing framework for quantum neural networks,"Shao, Minqi, and Jianjun Zhao",2025.0,,ArXiv,https://arxiv.org/abs/2411.02450,ArXiv,"Quantum Neural Networks (QNNs) integrate quantum computing and deep neural networks, leveraging quantum properties like superposition and entanglement to enhance machine learning algorithms. These characteristics enable QNNs to outperform classical neural networks in tasks such as quantum chemistry simulations, optimization problems, and quantum-enhanced machine learning. Despite their early success, their reliability and safety issues have posed threats to their applicability. However, due to the inherently non-classical nature of quantum mechanics, verifying QNNs poses significant challenges. To address this, we propose QCov, a set of test coverage criteria specifically designed to systematically evaluate QNN state exploration during testing, with an emphasis on superposition. These criteria help evaluate test diversity and detect underlying defects within test suites. Extensive experiments on benchmark datasets and QNN models validate QCov's effectiveness in reflecting test quality, guiding fuzz testing efficiently, and thereby improving QNN robustness. We also evaluate sampling costs of QCov under realistic quantum scenarios to justify its practical feasibility. Finally, the effects of unrepresentative training data distribution and parameter choice are further explored.","@article{shao2024coverage,
  title={A coverage-guided testing framework for quantum neural networks},
  author={Shao, Minqi and Zhao, Jianjun},
  journal={arXiv preprint arXiv:2411.02450},
  year={2024}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],"[Quantum learning-based models: Quantum Circuit Learning, Circuit-centric Quantum Classfiers, Quantum Convolutional Neural Network, Hierarchical Circuit Quantum Classifier, Hybrid Quantum Neural Network]",[Un-specified],[Quantum learning-based models: 5],[Un-specified],[Un-specified],[N],[Un-specified],[Un-specified],[Un-specified],[Y],[Random testing],[Naivety],[Un-specified],[Classical inputs: images],[20% of original dataset],[Ideal simulator],[Measurement outcome],"[Varied: 100, 1000, 10000, 100,000]",[Un-specified],[Specification: True label],[Un-specified],"[Coverage criteria], [Test Success Rate]",[Sampling costs],[N],N/A
108.0,Testing Quantum Programs with Multiple Subroutines,"Long, Peixun and Zhao, Jianjun",2022.0,,ArXiv,https://arxiv.org/abs/2208.09206,ArXiv,"Errors in quantum programs are challenging to track down due to the uncertainty of quantum programs. Testing is, therefore, an indispensable method for assuring the quality of quantum software. Existing testing methods focus only on testing quantum programs with quantum circuits or single subroutines and, therefore, cannot effectively test quantum programs with multi-subroutines. In this paper, we first discuss several critical issues that must be considered when testing multi-subroutine quantum programs and point out the limitations and problems with existing testing methods. We then present a novel framework for testing multi-subroutine quantum programs that allow for both unit and integration testing. Our framework includes two novel test coverage criteria for the equivalent class partition of quantum variables to guide our testing tasks and techniques to test quantum programs with several common patterns. We also discuss how to generate test cases based on our framework. To evaluate the effectiveness of our testing framework, we implemented a tool called QSharpTester for testing Q\# programs with multiple subroutines. We used it to conduct experiments on hundreds of mutation programs deriving from seven original Q\# programs. The experimental results show that our testing methods can deal with broader types of quantum programs than existing ones and perform well on almost all faulty mutation programs.","@article{long2022testing,
  title={Testing quantum programs with multiple subroutines},
  author={Long, Peixun and Zhao, Jianjun},
  journal={arXiv preprint arXiv:2208.09206},
  year={2022}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],"[Quantum algorithms and subroutines: Quantum Fourier Transform <Raw and Inverse>, Grover Search, Purity Identification <Purity>, Swap Qubits, Reverse Qubits <Reverse>, Phase Flip <Grover subroutine>]",[Un-specified],[Quantum algorithms and subroutines: 7],"[Mutation operators: Add gate, Delete gate, Move gate, Add calling statements, Remove calling statements, Modify calling statements, Modify control-flow statements, Modify classical variables, Add measurement, Delete measurement, Modify measurement]","[Mutants: 66, 16, 17, 31, 38, 14]",[Y],[Un-specified],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Initial quantum states: selected from quantum equivalence classes],[2*n_qubits^2],[Ideal simulator],[Measurement outcome],[Fixed: 200],[Un-specified],[Property: General property],[Property-based oracle: program specification],"[Trigger rate], [Number of unkilled mutants]",[Run time],[N],N/A
109.0,Evaluating Mutation-based Fault Localization for Quantum Programs,"Ishimoto, Yuta and Kondo, Masanari and Ubayashi, Naoyasu and Kamei, Yasutaka and Katsube, Ryota and Sato, Naoto and Ogawa, Hideto",2025.0,,ArXiv,https://arxiv.org/abs/2505.09059,ArXiv,"Quantum computers leverage the principles of quantum mechanics to execute operations. They require quantum programs that define operations on quantum bits (qubits), the fundamental units of computation. Unlike traditional software development, the process of creating and debugging quantum programs requires specialized knowledge of quantum computation, making the development process more challenging. In this paper, we apply and evaluate Origin program output fault localization (MBFL) for quantum programs with the aim of enhancing debugging efficiency. We use quantum mutation operations, which are specifically designed for quantum programs, to identify faults. Our evaluation involves 23 real-world faults and 305 artificially induced faults in quantum programs developed with Qiskit(R). The results show that real-world faults are more challenging for MBFL than artificial faults. In fact, the median EXAM score, which represents the percentage of the code examined before locating the faulty statement (lower is better), is 1.2% for artificial benchmark and 19.4% for the real-world benchmark in the worst-case scenario. Our study highlights the potential and limitations of MBFL for quantum programs, considering different fault types and mutation operation types. Finally, we discuss future directions for improving MBFL in the context of quantum programming.","@article{ishimoto2025evaluating,
  title={Evaluating Origin program output Fault Localization for Quantum Programs},
  author={Ishimoto, Yuta and Kondo, Masanari and Ubayashi, Naoyasu and Kamei, Yasutaka and Katsube, Ryota and Sato, Naoto and Ogawa, Hideto},
  journal={arXiv preprint arXiv:2505.09059},
  year={2025}
}",[Y],[Y],[ArXiv],[Preprint],[Fault localization],"[Real-world benchmarks: Bugs4Q], [Quantum algorithms and subroutines: Un-specified]","[Qiskit aqua library: [Un-specified], https://github.com/qiskit-community/qiskit-aqua#migration-guide], [Bugs4Q: [@inproceedings{zhao2021bugs4q,
  title={Bugs4Q: A benchmark of real bugs for quantum programs},
  author={Zhao, Pengzhan and Zhao, Jianjun and Miao, Zhongtao and Lan, Shuhan},
  booktitle={2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  pages={1373--1376},
  year={2021},
  organization={IEEE}
}], https://github.com/Z-928/Bugs4Q]","[Real-world benchmarks: 23], [Quantum algorithms and subroutines: Un-specified]","[Real-world bugs: Bugs4Q], [Mutation tooling: QMutPy]",[Mutants: 305],[N],[Un-specified],[Un-specified],[Un-specified],[Y],[Spectrum-based fault localization],[Adaption],"[Wilcoxon signed-rank test: $p$-value, Cliff's $\delta$]",[Un-specified],[From 1 to 593],[Ideal simulator],[Un-specified],[Un-specified],[Un-specified],[Original program output],[Un-specified],"[Number of behavior-changing mutants], [EXAM score]",[Un-specified],[N],N/A
112.0,On the Feasibility of Quantum Unit Testing,"Miranskyy, Andriy and Campos, Jos{\'e} and Mjeda, Anila and Zhang, Lei and de Guzm{\'a}n, Ignacio Garc{\'\i}a Rodr{\'\i}guez",2025.0,,ArXiv,https://arxiv.org/abs/2507.17235,ArXiv,"The increasing complexity of quantum software presents significant challenges for software verification and validation, particularly in the context of unit testing. This work presents a comprehensive study on quantum-centric unit tests, comparing traditional statistical approaches with tests specifically designed for quantum circuits. These include tests that run only on a classical computer, such as the Statevector test, as well as those executable on quantum hardware, such as the Swap test and the novel Inverse test. Through an empirical study and detailed analysis on 1,796,880 mutated quantum circuits, we investigate (a) each test's ability to detect subtle discrepancies between the expected and actual states of a quantum circuit, and (b) the number of measurements required to achieve high reliability. The results demonstrate that quantum-centric tests, particularly the Statevector test and the Inverse test, provide clear advantages in terms of precision and efficiency, reducing both false positives and false negatives compared to statistical tests. This work contributes to the development of more robust and scalable strategies for testing quantum software, supporting the future adoption of fault-tolerant quantum computers and promoting more reliable practices in quantum software engineering.","@article{miranskyy2025feasibility,
  title={On the Feasibility of Quantum Unit Testing},
  author={Miranskyy, Andriy and Campos, Jos{\'e} and Mjeda, Anila and Zhang, Lei and de Guzm{\'a}n, Ignacio Garc{\'\i}a Rodr{\'\i}guez},
  journal={arXiv preprint arXiv:2507.17235},
  year={2025}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],"[Quantum algorithms and subroutines: Un-specified], [Artificial programs] ","[MQT bench: [@article{quetschlich2023mqt,
  title={MQT Bench: Benchmarking software and design automation tools for quantum computing},
  author={Quetschlich, Nils and Burgholzer, Lukas and Wille, Robert},
  journal={Quantum},
  volume={7},
  pages={1062},
  year={2023},
  publisher={Verein zur F{\""o}rderung des Open Access Publizierens in den Quantenwissenschaften}}
], https://www.cda.cit.tum.de/mqtbench/]""","[Quantum algorithms and subroutines: Un-specified], [Artificial programs: 10000]","[Mutation operators: Add gate, Delete gate, Replace gate]",[Mutants: 1796880],[N],"[1,2,3,4,5]",[Un-specified],[From 1 to 10],[Y],"[Swap test], [Statevector test], [Pearson's chi-squared test], [G-test], [Multinomial test], [Monte Carlo Pearson's chi-squared test], [Monte Carlo G-test], [Monte Carlo Multinomial test]","[Adaption], [Adaption],[SOTA],[Adaption],[Adaption],[Adaption],[Adaption],[Adaption]",[Un-specified],[Initial quantum states: Default state],[Un-specified],[Ideal simulator],"[Measurement outcome],[State vector]","[Fixed: $10^5$, $10^7$], [Varied: From 1 to 10000], [Adaptive: The maximum determined by the Quantum Chernoff bound]","[100, 200, 1000]",[Specification: Quantum state],"[Output distribution oracle: Pearson's chi-squared test, G-test, Multinomial test, Monte Carlo Pearson's chi-squared test, Monte Carlo G-test, Monte Carlo Multionmial test], [Wrong output oracle: Inverse test, Swap test]","[Number of true positives], [Number of false negatives], [Number of true negatives], [Number of false positives], [Accuracy], [Recall], [Precision], [F1 score]",[Un-specified],[N],N/A
113.0,QCRMut: Quantum circuit random mutant generator tool,"Gil, Sinhu{\'e} Garc{\'\i}a and D{\'\i}az, Luis Llana and Jarabo, Jos{\'e} Ignacio Requeno",2024.0,,ArXiv,https://arxiv.org/abs/2410.01415,ArXiv,"Quantum computing has been on the rise in recent years, evidenced by a surge in publications on quantum software engineering and testing. Progress in quantum hardware has also been notable, with the introduction of impressive systems like Condor boasting 1121 qubits, and IBM Quantum System Two, which employs three 133-qubit Heron processors. As this technology edges closer to practical application, ensuring the efficacy of our software becomes imperative. Mutation testing, a well-established technique in classical computing, emerges as a valuable approach in this context.
In our paper, we aim to introduce QCRMut, a mutation tool tailored for quantum programs, leveraging the inherent Quantum Circuit structure. We propose a randomised approach compared to previous works with exhaustive creation processes and the capability for marking immutable positions within the circuit. These features facilitate the preservation of program structure, which is crucial for future applications such as metamorphic testing.","@article{gil2024qcrmut,
  title={QCRMut: Quantum circuit random mutant generator tool},
  author={Gil, Sinhu{\'e} Garc{\'\i}a and D{\'\i}az, Luis Llana and Jarabo, Jos{\'e} Ignacio Requeno},
  journal={arXiv preprint arXiv:2410.01415},
  year={2024}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],"[Quantum algorithms and subroutines: Quantum Fourier Transform <Inverse Quantum Fourier Transform>, Quantum Conditional Execution, Bernstein-Vazirani Algorithm]",[Un-specified],[Quantum algorithms and subroutines: 3],"[Mutation operators: Add gate, Delete gate, Replace gate, Modify qubit]","[Mutants: 500, 288, 160]",[N],[Un-specified],"[Total: 24, 17, 9]",[Un-specified],[Y],"[QMutPy], [Muskit]","[SOTA], [SOTA]",[Un-specified],[Initial quantum states: Computational basis states],[Un-specified],[Ideal simulator],[Measurement outcome],"[Fixed: 100, 1024]",[Un-specified],[Specification: Probability distribution],"[Wrong output oracle: None],[Output probability oracle: specified]",[Mutation score],"[Overall execution time],[Memory usage]",[Y],[GitHub: https://github.com/sinugarc/QCRMut]
114.0,QUT: A Unit Testing Framework for Quantum Subroutines,Mykhailo V. Klymenko and Thong Hoang and Hoa Nguyen and Samuel A. Wilkinson and Bahar Goldozian and Xing Zhenchang and Qinghua Lu and Muhammad Usman and Liming Zhu,2025.0,,ArXiv,https://arxiv.org/abs/2509.17538,ArXiv,"We present the architectural design and prototype implementation of QUT (Quantum Unit Testing), a framework for unit testing of quantum subroutines. The framework is developed with a focus on usability and simplicity, making the complex theoretical concepts behind quantum unit testing accessible to a wide range of users with diverse backgrounds. This is achieved through the implementation of polymorphic probabilistic assertions, whose evaluation methods adapt to the data types of the arguments used in assertion statements, which may vary according to the context-dependent semantics of quantum subroutines. These arguments can be represented as qubit measurement outcomes, density matrices, or Choi matrices. For each type, the architecture integrates a specific testing protocol - such as quantum process tomography, quantum state tomography, or Pearson's chi-squared test - while remaining flexible enough to incorporate additional protocols in the future. The framework is built on the Qiskit software stack, providing compatibility with a broad range of quantum hardware backends and simulation platforms. Drawing on the reasoning provided by the denotational semantics of quantum subroutines, this work also highlights the key distinctions between quantum unit testing and its classical counterpart.","@article{klymenko2025qut,
  title={QUT: A Unit Testing Framework for Quantum Subroutines},
  author={Klymenko, Mykhailo V and Hoang, Thong and Nguyen, Hoa and Wilkinson, Samuel A and Goldozian, Bahar and Zhenchang, Xing and Lu, Qinghua and Usman, Muhammad and Zhu, Liming},
  journal={arXiv preprint arXiv:2509.17538},
  year={2025}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],[Quantum algorithms and subroutines: Bell State Preparation],[Un-specified],[Quantum algorithms and subroutines:1],[None],[None],[N],[Un-specified],[Un-specified],[Un-specified],[N],N/A,N/A,[Un-specified],[Un-specified],[Un-specified],"[Ideal simulator], [Noisy simulator]","[Measurement outcome],[Density matrix], [Quantum process]",[Fixed: 3000],[Un-specified],"[Specification: Quantum state],[Specification: Probability distribution],[Specification: Quantum evolve/operator]","[Output probability oracle:Pearson's chi-square test],[Quantum state oracle: Uhlmann-Hozsa fidelity],[Quantum evolve/operator oracle: Uhlmann-Hozsa fidelity]",[Number of passing tests],[Un-specified],[N],[GitHub: https://github.com/csiro/QUT/tree/main]
115.0,Bloch Vector Assertions for Debugging Quantum Programs,Noah H. Oldfield and Christoph Laaber and Shaukat Ali,2025.0,,ArXiv,https://arxiv.org/abs/2506.18458,ArXiv,"Quantum programs must be reliable to ensure trustworthy results, yet debugging them is notoriously challenging due to quantum-specific faults like gate misimplementations and hardware noise, as well as their inherently probabilistic nature. Assertion-based debugging provides a promising solution by enabling localized correctness checks during execution. However, current approaches face challenges including manual assertion generation, reliance on mid-circuit-measurements, and poor scalability. In this paper, we present Bloq, a scalable, automated fault localization approach introducing Bloch-vector-based assertions utilizing expectation value measurements of Pauli operators, enabling low-overhead fault localization without mid-circuit measurements. In addition, we introduce AutoBloq, a component of Bloq for automatically generating assertion schemes from Quantum algorithms and subroutines. An experimental evaluation over 684432 programs using two algorithms (Quantum Fourier Transform (QFT) and Grover Search) shows that Bloq consistently outperforms the state-of-the-art approach Proq, notably as circuit depth and noise increase. For Grover Search, Bloq achieves a mean F1 score across all experimental instances of 0.74 versus 0.38 for Proq under ideal conditions, and maintains performance under noise (0.43 versus 0.06). Bloq also reduces Proq's runtime by a factor of 5 and circuit depth overhead by a factor of 23. These results underline Bloq's potential to make assertion-based debugging scalable and effective for near-term quantum devices.","@article{oldfield2025bloch,
  title={Bloch Vector Assertions for Debugging Quantum Programs},
  author={Oldfield, Noah H and Laaber, Christoph and Ali, Shaukat},
  journal={arXiv preprint arXiv:2506.18458},
  year={2025}
}",[Y],[Y],[ArXiv],[Preprint],[Runtime assertion],"[Quantum algorithms and subroutines: Grover Search, Quantum Fourier Transform]",[Un-specified],[Quantum algorithms and subroutines: 2],[Mutation],[1710],[Y],"[From 2 to 6, From 2 to 10]",[Un-specified],[Un-specified],[Y],[Proq],[SOTA],[Un-specified],[Initial quantum states: Computational basis states],[Number of computationial basis],"[Ideal simulator], [Noisy simulator]","[Density matrix], [Quantum process]",[Fixed: 8192],[Un-specified],[Specification: Quantum state],[Quantum state oracle: Uhlmann-Hozsa fidelity],"[F1 Score], [Circuit Depth]","[Number of gates], [Number of measurement operations], [Number of qubits]",[Un-specified],[Zenodo: https://zenodo.org/records/15708438]
116.0,Distinguishing Quantum Software Bugs from Hardware Noise: A Statistical Approach,Ahmik Virani and Devraj and Anirudh Suresh and Lei Zhang and M V Panduranga Rao,2025.0,,ArXiv,https://arxiv.org/pdf/2507.20475,ArXiv,"Quantum computing in the Noisy Intermediate-Scale Quantum (NISQ) era presents significant challenges in differentiating quantum software bugs from hardware noise. Traditional debugging techniques from classical software engineering cannot directly resolve this issue due to the inherently stochastic nature of quantum computation mixed with noises from NISQ computers. To address this gap, we propose a statistical approach leveraging probabilistic metrics to differentiate between quantum software bugs and hardware noise. We evaluate our methodology empirically using well-known Quantum algorithms and subroutines, including Grover Search's algorithm, Deutsch-Jozsa Algorithm algorithm, and Simon's algorithm. Experimental results demonstrate the efficacy and practical applicability of our approach, providing quantum software developers with a reliable analytical tool to identify and classify unexpected behavior in quantum programs.","@article{Virani2025DistinguishingQS,
  title={Distinguishing Quantum Software Bugs from Hardware Noise: A Statistical Approach},
  author={Ahmik Virani and Devraj and Anirudh Suresh and Lei Zhang and M. V. Panduranga Rao},
  journal={ArXiv},
  year={2025},
  volume={abs/2507.20475},
  url={https://api.semanticscholar.org/CorpusID:280323370}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],"[Quantum algorithms and subroutines: Grover Search, Deutsch-Jozsa Algorithm Algorithm, Simon's Algorithm]",[Un-specified],[Quantum algorithms and subroutines: 3],[Mutation toolings: Muskit],[Mutants: 3560],[Y],[From 2 to 15],"[Total: 51, 8.5, 144.5, 8 <Float numbers indicating the average>]",[From 1 to 5],[N],N/A,N/A,N/A,[Initial quantum states: Computational basis states],[Un-specified],[Ideal simulator],[Measurement outcome],"[Fixed: 10,000]",[Un-specified],[Original program output],[Un-specified],"[Bias, Entropy]",[Un-specified],[Y],[GitHub:https://github.com/Ahmik-Virani/Differentiating-Quantum-Bug-From-Noise-Statistical-Approach]
117.0,Context-Aware Unit Testing for Quantum Subroutines,Mykhailo Klymenko and Thong Hoang and Samuel A. Wilkinson and Bahar Goldozian and Suyu Ma and Xiwei Xu and Qinghua Lu and Muhammad Usman and Liming Zhu,2025.0,,ArXiv,https://arxiv.org/abs/2506.10348,ArXiv,"Software testing is a critical component of the classical software development lifecycle, and this principle is expected to hold true for quantum software as it evolves toward large-scale production and adherence to industry standards. Developing and testing quantum software presents unique challenges due to the non-deterministic nature of quantum information, the high dimensionality of the underlying Hilbert space, complex hardware noise, and the inherent non-local properties of quantum systems. In this work, we model quantum subroutines as parametrized quantum channels and explore the feasibility of creating practical unit tests using probabilistic assertions, combined with either quantum tomography or statistical tests. To address the computational complexity associated with unit testing in quantum systems, we propose incorporating context-awareness into the testing process. The trade-offs between accuracy, state space coverage, and efficiency associated with the proposed theoretical framework for quantum unit testing have been demonstrated through its application to a simple three-qubit quantum subroutine that prepares a Greenberger-Horne-Zeilinger state, as well as to subroutines within a program implementing Shor's algorithm.","@article{klymenko2025context,
  title={Context-Aware Unit Testing for Quantum Subroutines},
  author={Klymenko, Mykhailo and Hoang, Thong and Wilkinson, Samuel A and Goldozian, Bahar and Ma, Suyu and Xu, Xiwei and Lu, Qinghua and Usman, Muhammad and Zhu, Liming},
  journal={arXiv preprint arXiv:2506.10348},
  year={2025}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],"[Quantum algorithms and subroutines: Cat State Preparation <Greenberger-Horne-Zeilinger State Preparation>, Quantum Phase Estimation]",[Un-specified],[Quantum algorithms and subroutines: 2],"[Mutation operators: Move gate, Replace gate, Add gate]",[Un-specified],[N],[3],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,"[Initial quantum states: Default state, Eigenvector of a unitary operation], [Classical inputs: Un-specified]",[Un-specified],"[Ideal simulator],[Noisy simulator]",[Measurement outcome],[Varied: From $10^0$ to $10^5$],[Un-specified],"[Specification: Quantum state],[Specification: Quantum operator]","[Output distribution oracle: Pearson's chi-square test], [Quantum state oracle: Quantum process tomography]",[Probability of passing and failing],[Average wall time],[N],N/A
119.0,"QuCheck: A Property-based Testing Framework for Quantum
Programs in Qiskit
","Property-based testing has been previously proposed for quantum programs in Q# with QSharpCheck, however, this implementation was limited in functionality, lacked extensibility, and was evaluated on a narrow range of programs using a single property. To address these limitations, we propose QuCheck, an enhanced property-based testing framework in Qiskit. By leveraging Qiskit and the broader Python ecosystem, QuCheck facilitates property construction, introduces flexible input generators and assertions, and supports expressive preconditions. We assessed its effectiveness through mutation analysis on five quantum programs (2-10 qubits), varying the number of properties, inputs, and measurement shots to assess their impact on fault detection and demonstrate the effectiveness of property-based testing across a range of conditions. Results show a strong positive correlation between the mutation score (a measure of fault detection) and number of properties evaluated, with a moderate negative correlation between the false positive rate and number of measurement shots. Among the most thorough test configurations, those evaluating three properties achieved a mean mutation score ranging from 0.90 to 0.92 across all five algorithms, with the false positive rate between 0 and 0.04. QuCheck identified 36.0% more faults than QSharpCheck, with execution time reduced by 81.1%, despite one false positive. These findings underscore the viability of property-based testing for verifying quantum systems.",2025.0,,ArXiv,https://arxiv.org/abs/2503.22641,ArXiv,"Property-based testing has been previously proposed for quantum programs in Q# with QSharpCheck, however, this implementation was limited in functionality, lacked extensibility, and was evaluated on a narrow range of programs using a single property. To address these limitations, we propose QuCheck, an enhanced property-based testing framework in Qiskit. By leveraging Qiskit and the broader Python ecosystem, QuCheck facilitates property construction, introduces flexible input generators and assertions, and supports expressive preconditions. We assessed its effectiveness through mutation analysis on five quantum programs (2-10 qubits), varying the number of properties, inputs, and measurement shots to assess their impact on fault detection and demonstrate the effectiveness of property-based testing across a range of conditions. Results show a strong positive correlation between the mutation score (a measure of fault detection) and number of properties evaluated, with a moderate negative correlation between the false positive rate and number of measurement shots. Among the most thorough test configurations, those evaluating three properties achieved a mean mutation score ranging from 0.90 to 0.92 across all five algorithms, with the false positive rate between 0 and 0.04. QuCheck identified 36.0% more faults than QSharpCheck, with execution time reduced by 81.1%, despite one false positive. These findings underscore the viability of property-based testing for verifying quantum systems.","@article{pontolillo2025qucheck,
  title={QuCheck: A Property-based Testing Framework for Quantum Programs in Qiskit},
  author={Pontolillo, Gabriel and Mousavi, Mohammad Reza and Grzesiuk, Marek},
  journal={arXiv preprint arXiv:2503.22641},
  year={2025}
}",[Y],[Y],[ArXiv],[Preprint],[Software testing],"[Quantum algorithms and subroutines: Deutsch-Jozsa Algorithm, Grover Search, Quantum Phase Estimation, Quantum Fourier Transform, Quantum Teleportation]",[Un-specified],[Quantum algorithms and subroutines: 5],[Mutation toolings: QMutPy],[Mutants: 50],[N],[From 2 to 10],[Un-specified],[Un-specified],[Y],[QSharpCheck],[SOTA],[Un-specified],[Initial quantum states: random generator (UCNOT in QuraTest)],[10],[Ideal simulator],[Measurement outcome],[Varied: From 12 to 3200],[1],[Property: General property],[Property-based oracle: None],[Mutation score],[Overall execution time],[Y],[Figshare: https://figshare.com/articles/software/QuCheck_A_Property-based_Testing_Framework_for_Quantum_Programs_in_Qiskit/27919539?file=53357996]
121.0,Proq: Projection-based runtime assertions for debugging on a quantum computer,Gushu Li and Li Zhou and Nengkun Yu and Yufei Ding and Mingsheng Ying and Yuan Xie,2019.0,,ArXiv,https://arxiv.org/abs/1911.12855,ArXiv,"In this paper, we propose Proq, a runtime assertion scheme for testing and debugging quantum programs on a quantum computer. The predicates in Proq are represented by projections (or equivalently, closed subspaces of the state space), following Birkhoff-von Neumann quantum logic. The satisfaction of a projection by a quantum state can be directly checked upon a small number of projective measurements rather than a large number of repeated executions. On the theory side, we rigorously prove that checking projection-based assertions can help locate bugs or statistically assure that the semantic function of the tested program is close to what we expect, for both exact and approximate quantum programs. On the practice side, we consider hardware constraints and introduce several techniques to transform the assertions, making them directly executable on the measurement-restricted quantum computers. We also propose to achieve simplified assertion implementation using local projection technique with soundness guaranteed. We compare Proq with existing quantum program assertions and demonstrate the effectiveness and efficiency of Proq by its applications to assert two ingenious Quantum algorithms and subroutines, the Harrow-Hassidim-Lloyd algorithm and Shor's algorithm.","@article{li2019proq,
  title={Proq: Projection-based runtime assertions for debugging on a quantum computer},
  author={Li, Gushu and Zhou, Li and Yu, Nengkun and Ding, Yufei and Ying, Mingsheng and Xie, Yuan},
  journal={arXiv preprint arXiv:1911.12855},
  year={2019}
}",[Y],[Y],[ArXiv],[Preprint],[Runtime assertion]," [Quantum algorithms and subroutines: Shor's Algorithm <Quantum Order Finding Subroutine of Shor's Algorithm>, Harrow-Hassidim-Lloyd Algorithm]",[Un-specified],[Quantum algorithms and subroutines: 2],[Un-specified],[Un-specified],[N],[5],[Un-specified],[Un-specified],[Y],[QECA],[SOTA],[Un-specified],"[Classical inputs: Orthonormal vectors],[Initial quantum states: Default state]",[1],[Ideal simulator],"[Measurement outcome],[State vector]",[Un-specified],[Un-specified],[Specification: Quantum state],[Wrong output oracle: Projectors using extra transformation],[Un-specified],"[Number of gates], [Number of measurement operations], [Number of qubits]",[N],N/A
122.0,Quantum Circuits for Dynamic Runtime Assertions in Quantum Computation,"Liu, Ji and Byrd, Gregory T. and Zhou, Huiyang",2020.0,10.1145/3373376.3378488,Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems,https://dl.acm.org/doi/abs/10.1145/3373376.3378488,Association for Computing Machinery,"In this paper, we propose quantum circuits for runtime assertions, which can be used for both software debugging and error detection. Runtime assertion is challenging in quantum computing for two key reasons. First, a quantum bit (qubit) cannot be copied, which is known as the non-cloning theorem. Second, when a qubit is measured, its superposition state collapses into a classical state, losing the inherent parallel information. In this paper, we overcome these challenges with runtime computation through ancilla qubits, which are used to indirectly collect the information of the qubits of interest. We design quantum circuits to assert classical states, entanglement, and superposition states. Our experimental results show that they are effective in debugging as well as improving the success rate for various Quantum algorithms and subroutines on IBM Q quantum computers.","@inproceedings{10.1145/3373376.3378488,
author = {Liu, Ji and Byrd, Gregory T. and Zhou, Huiyang},
title = {Quantum Circuits for Dynamic Runtime Assertions in Quantum Computation},
year = {2020},
isbn = {9781450371025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373376.3378488},
doi = {10.1145/3373376.3378488},
abstract = {In this paper, we propose quantum circuits for runtime assertions, which can be used for both software debugging and error detection. Runtime assertion is challenging in quantum computing for two key reasons. First, a quantum bit (qubit) cannot be copied, which is known as the non-cloning theorem. Second, when a qubit is measured, its superposition state collapses into a classical state, losing the inherent parallel information. In this paper, we overcome these challenges with runtime computation through ancilla qubits, which are used to indirectly collect the information of the qubits of interest. We design quantum circuits to assert classical states, entanglement, and superposition states. Our experimental results show that they are effective in debugging as well as improving the success rate for various Quantum algorithms and subroutines on IBM Q quantum computers.},
booktitle = {Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {1017–1030},
numpages = {14},
keywords = {runtime assertion, quantum computing},
location = {Lausanne, Switzerland},
series = {ASPLOS '20}
}",[Y],[Y],[International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)],[Conference],[Runtime assertion],"[Quantum algorithms and subroutines: Quantum Fourier Transform, Quantum Phase Estimation, Bernstein-Vazirani Algorithm, Toffoli Gate, Quantum Adder <1-bit Adder>, Deutsch-Jozsa Algorithm <4-bit>]",[Un-specified],[Quantum algorithms and subroutines: 6],[None],[None],[Y],"[2, 3, 4]",[Un-specified],[Un-specified],[Y],[Approach without assertion],[Ablation],[Un-specified],[Initial quantum states: Uniform superposition state],[Un-specified],"[Ideal simulator],[Physical hardware]",[Measurement outcome],[Fixed: 8192],[5],[Property: General property],[Property-based oracle: Extra quantum operations involving ancilla qubits],"[Fidelity], [Probability of false positives], [Success rate]",[Un-specified],[Y],"[GitHub:https://github.com/revilooliver/Quantum-Circuits-for-Dynamic-Runtime-Assertions-in-Quantum-Computation], [Zenodo: https://zenodo.org/records/3597507]"
123.0,AQUA: Analytics-driven quantum neural network (QNN) user assistance for software validation,"Park, Soohyun and Baek, Hankyul and Yoon, Jung Won and Lee, Youn Kyu and Kim, Joongheon",2024.0,https://doi.org/10.1016/j.future.2024.05.047,Future Generation Computer Systems,https://www.sciencedirect.com/science/article/pii/S0167739X24002796,Elsevier,"This paper proposes a novel analytics-driven user assistance software validation approach for quantum neural network (QNN) codes. The proposed analytics-driven QNN user assistance (AQUA) for software validation considers user interactive feedback for constructing efficient QNN software. Our proposed AQUA is based on dynamic software testing and analysis due to undetermined qubit states in QNN which is hard to be tracked via static software analysis. AQUA is for plotting gradient variances to determine whether the QNN software suffers from local minima situations, which are called barren plateaus in QNN. By utilizing AQUA software validation, the stability, feasibility, and explainability of QNN software can be tested. AQUA has been tested using real-world case study with quantum convolutional neural network software for point cloud data processing in autonomous driving applications.","@article{park2024aqua,
  title={AQUA: Analytics-driven quantum neural network (QNN) user assistance for software validation},
  author={Park, Soohyun and Baek, Hankyul and Yoon, Jung Won and Lee, Youn Kyu and Kim, Joongheon},
  journal={Future Generation Computer Systems},
  volume={159},
  pages={545--556},
  year={2024},
  publisher={Elsevier}
}",[Y],[Y],[Future Generation Computer Systems (FGCS)],[Journal],[Software testing],"[Quantum learning-based models: Quantum Convolutional Neural Network], [Quantum applications: Object Detection]",[Un-specified],[Quantum learning-based models:1],[Imperfect models],[Un-specified],[N],[Un-specified],[Un-specified],[Un-specified],[Y],[Approach without AQUA],[Ablation],[Un-specified],[Classical inputs: Images],[Un-specified],[Un-specified],[Measurement outcome],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Accuracy],[Overall execution time],[N],N/A
124.0,EQuaTE: Efficient Quantum Train Engine for Runtime Dynamic Analysis and Visual Feedback in Autonomous Driving,"Park, Soohyun and Feng, Hao and Park, Chanyoung and Lee, Youn Kyu and Jung, Soyi and Kim, Joongheon",2023.0,10.1109/MIC.2023.3307395,IEEE Internet Computing,https://ieeexplore.ieee.org/abstract/document/10229500,IEEE Press,"This article proposes an efficient quantum train engine (EQuaTE), a novel development tool for quantum neural network (QNN) autonomous driving software, which plots gradient variances to confirm whether the QNN falls into local minima situations (called barren plateaus). Based on this runtime visualization, the stability and feasibility of QNN-based software can be tested during runtime operations of autonomous driving functionalities. This software testing of a QNN via dynamic analysis is essentially required due to undetermined probabilistic qubit states during runtime operations. Furthermore, an EQuaTE is capable of visual feedback because the barren plateaus can be identified at local autonomous driving platforms, and the corresponding information will be visualized at remotely connected cloud. Based on this visualized information at the cloud, the QNN, which is also stored at cloud, should be automatically reorganized and retrained for eliminating barren plateaus. Then, the trained parameters can be downloaded into the QNN of autonomous driving platforms.","@ARTICLE{10229500,
  author={Park, Soohyun and Feng, Hao and Park, Chanyoung and Lee, Youn Kyu and Jung, Soyi and Kim, Joongheon},
  journal={IEEE Internet Computing}, 
  title={EQuaTE: Efficient Quantum Train Engine for Runtime Dynamic Analysis and Visual Feedback in Autonomous Driving}, 
  year={2023},
  volume={27},
  number={5},
  pages={24-31},
  keywords={Autonomous vehicles;Visualization;Qubit;Training;Vehicle dynamics;Task analysis;Railway engineering;Runtime},
  doi={10.1109/MIC.2023.3307395}}
",[Y],[Y],[IEEE Internet Computing],[Journal],[Software testing],"[Quantum learning-based models: Un-specified], [Quantum applications: Autonomous Driving]",[Un-specified],[Quantum learning-based models:1],[Imperfect models],[Un-specified],[N],[Un-specified],[Un-specified],[Un-specified],[N],N/A,N/A,N/A,[Un-specified],[Un-specified],[Un-specified],[Measurement outcome],[Un-specified],[Un-specified],[Un-specified],[Un-specified],[Accuracy],[Overall execution time],[N],N/A
